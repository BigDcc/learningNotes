# **4** ***\*Python3包，模块\****

## ***\*5\*******\*.1 模块的定义\****

模块是最高级别的程序组织单元，它将程序代码和数据封装起来以便再利用，同时提供自包含的命名空间从而避免程序出现变量名冲突。

从实际角度看，每一个python程序的源码文件都可以看做是一个模块。模块导入操作的本质上来讲就是将模块文件通过导入的形式生成模块对象，然后通过句点运算符去访问对象的属性（object.attribute）（模块文件的全局作用域变成了模块对象的属性命名空间，可以通过句点运算符进行访问）。

模块可以用于组织多文件形式的python程序，使我们开发大规模的程序，而不单单停留在脚本层面，具体形式诸如：通过一个顶层文件导入依赖模块，然后将顶层文件作为启动入口，进而运行整个程序。一个基本的python程序架构如下图所示：

![img](file:////tmp/wps-achui/ksohtml/wpsnjLJwz.jpg) 

## ***\*5.2\**** ***\*模块分类与模块源文件\****

![img](file:////tmp/wps-achui/ksohtml/wpsq0ZpCz.jpg) 

如上图所示，一般我们导入的模块文件大致可以分为以上几类，而实现模块不止可以通过python去实现，也可以通过其他语言去实现，Python在执行导入的时候，对于后缀名是忽略的，在sys.path这个列表中从左到右的寻找着相匹配的模块文件。（有点像Linux中执行命令时通过PATH这个变量寻找可执行文件的过程）

以下是模块导入时支持的一些源码文件类型，当然目前阶段了解即可，我们目前主要学习的是基于python怎么实现模块文件的编写引用，以及如何调用他人写好的模块以及python自身提供的一些内置模块。

![img](file:////tmp/wps-achui/ksohtml/wpszh8hGA.jpg) 

## ***\*5\*******\*.3\**** ***\*模块的语法\****

### ***\*5\*******\*.3.1\**** ***\*导入模块的语法\****

![img](file:////tmp/wps-achui/ksohtml/wpsZQIfTB.jpg) 

注意：

1）pep8要求，每个模块导入独占一行。所以不要在一行导入多个模块。

2）import导入模块时，应该放在程序的开头方便错误排查。

3）在导入同名模块时，后导入的会覆盖先导入的模块，这时用别名区分。

4）在开发中最好不要用*这种导入方式，出错时，排查困难。

延伸：

采用from导入模块之所以在调用模块对象属性时不需要显示的声明模块名，是因为from实现的本质是将原模块中的变量（不包含模块名）复制了一份放from所在的命名空间当中，当然不需要显示的声明模块名了，但是有个主意的事项，此时两个命名空间中的变量其实引用的是同一个对象。如下图所示：（B中复制了A中的变量，而B中变量在初始化时引用了被导入文件中的同名对象）

![img](file:////tmp/wps-achui/ksohtml/wpslp1QQB.jpg) 

我们修改B命名空间中的a变量，如果变量引用的对象是不可变得，则B中的a指向了新的对象，而A中的a依旧指向原本的对象，如果对象是可变的，则B中修改a的引用对象，则A中的a也会同步生效。当然如果需要每次都是同步生效的最好是使用import这种方式，直接操作的对象就是模块对象，不会因为复制的原因导致不同步的现象出现。（以下为代码实例）

![img](file:////tmp/wps-achui/ksohtml/wpsLNmWyz.jpg) 

import和from是可执行的语句，所以他们可以出现在条件测试，函数等语法结构中，但是from *这种语法形式只允许出现在模块文件的顶部位置。

from *导入文件的特殊设定：（可以通过_x或者__all__来控制from *的变量访问范围，防止from *更大范围的破坏命名空间）

![img](file:////tmp/wps-achui/ksohtml/wpsmE00MA.jpg) 

### ***\*5\*******\*.3.2\**** ***\*模块文件命名\****

模块文件的命名应该符合python中变量命名的规范，因为模块在被导入后，会以变量的形式被使用。

### ***\*5\*******\*.\*******\*3\*******\*.\*******\*3\**** ***\*给导入的模块其别名\****

![img](file:////tmp/wps-achui/ksohtml/wpsltPs7A.jpg) 

注意：

1）pep8要求，给模块起别名时需要使用大驼峰命名法

2）导入模块中函数的原则，只导入需要使用的函数，防止同名覆盖，发生未知错误（针对from来说）。

### ***\*5\*******\*.3.4\**** ***\*_\*******\*_name__\*******\*和_\*******\*_main__\****

每一模块都有一个名为__name__的内置属性，Python会遵守下面的规则自动创建并复制该属性。

1） 如果文件作为顶层程序文件执行，在启动时__name__就会被设置为字符串”__main__”；

2） 如果文件被导入，__name__就会被设置为对应的模块名。

### ***\*5\*******\*.3.4\**** ***\*模块重载（了解）\****

#### ***\*5\*******\*.3.4\*******\*.\*******\*1\**** ***\*重载函数r\*******\*eload\*******\*的定义\****

Python3中模块的重载通过reload函数实现，reload函数在imp模块中被实现，所以进行重载时需要引入该函数。

因为from关键字的特性，导致reload函数无法实现通过from导入的模块的内容的重载（from复制了被导入模块中的变量，reload重载会重新运行模块中的代码将原有的模块对象中的内容重新初始化，但是from中导入的变量引用的依旧是重载之前的对象值，所以使用重载时应该搭配import使用，而非from）

以下是《python学习手册》中对reload这个函数的描写说明：

![img](file:////tmp/wps-achui/ksohtml/wpsfQ2yAA.jpg) 

![img](file:////tmp/wps-achui/ksohtml/wpsV50JeB.jpg) 

#### ***\*5\*******\*.3.4.2\**** ***\*重载函数r\*******\*eload\*******\*的说明\****

![img](file:////tmp/wps-achui/ksohtml/wpstMjLoy.jpg) 

#### ***\*5\*******\*.3.4.3\**** ***\*重载函数的应用领域\****

通常情况下通过使用重载函数实现动态定制和更改模块代码后的测试。

## ***\*5\*******\*.4\**** ***\*模块导入基本原理解析\****

### ***\*5\*******\*.\*******\*4.1\**** ***\*导入模块执行流程\****

![img](file:////tmp/wps-achui/ksohtml/wpspawJDB.jpg) 

基于上图的导入流程（import流程）可以基本了解到python中关于导入的问题， 针对from导入其实是在第四步的基础上加一个变量的复制操作，将模块对象的变量复制到当前from所在的命名空间当中。而前面了解到的reload则是对这个模型的补充，通过重载我们可以保证程序运行的前提下，将模块对象重置。

### ***\*5\*******\*.4.2\**** ***\*模块搜索路径\****

![img](file:////tmp/wps-achui/ksohtml/wpsA0yC6x.jpg) 

上图揭示了python解释器自动寻找模块的基本流程，值得注意的是这个搜索流程是在给定的sys.path这个字典中逐一匹配的，一般找到同名的文件（后缀名无关紧要，因为python可以导入多种类型的模块源文件）既进行加载，而sys.path的组成来源中2和4可以提供自定义配置，方便我们定制化模块位置。

当然也可以直接修改标准库中的sys.path这个字典，来进行搜索路径的扩增。

#### ***\*5\*******\*.4.2.1 PYTHONPATH\*******\*配置与.\*******\*pth\*******\*配置\****

PYTHONPATH这个变量可以实现跨文件夹加载模块的功能，也是当前比较流行的一种客制化配置方法。在windows上可以通过添加环境变量的方式将键设置为PYTHONPATH，值设置为存放模块文件的目录，Linux上也是通过设置环境变量的方式添加该设置，不过我在网络上看到大家实际使用时的配置方式：

将PYTHONPATH的设置添加在虚拟环境的激活脚本当中（activate）,例如向activate中添加如下命令：

export PYTHONPATH=”/home/workspace/project”

​	至于.pth的方式，由于不经常使用这里简单的说明下，命名一个以.pth结尾的文件，将其放在解释器的根目录下，在文件中每行添加一个路径即可实现，扩展搜索路径的目的。

### ***\*5\*******\*.4.3\*******\*关于编译成字节码的说明\****

前面的知识中我们简单的介绍过标准实现的解释器执行模型，python3.2之后，会在模块文件的根目录生成一个__pycache__的文件夹用于存放生成的字节码文件。生成的字节码文件命名一般是这样module_1.cpython-37.pyc。

加载模块时，首先会查看是否存在用于加速的字节码文件，如果没有当然是需要先编译再运行的，如果字节码存在，则会判断两个标识，一个是时间戳，另一个是文件名标识，如果修改过文件则重新编译，如果换了其他的解释器也会重新编译但是不会覆盖以前的字节码文件（如以前的使用3.6现在的使用3.7是会共存的）。

## ***\*5\*******\*.5\**** ***\*关于包\****

除了导入模块名之外，python还可以导入目录路径，python代码的目录路径被称为包，所以这样的导入也被称为包导入。通过__init__.py文件的有无又可以将包导入分别划分为常规包导入和命名空间包导入。

导入语句中如果要描述一个目录路径应该使用python规定的点号进行间隔。

### ***\*5\*******\*.5.1 __init__\*******\*.\*******\*py\*******\*文件\****

以下为《Python学习手册》中对__init__.py文件的总结：

![img](file:////tmp/wps-achui/ksohtml/wpsY0P51x.jpg) 

​	Python3.3以后的版本对包导入进行了扩充，包中可以不含有__init__.py文件，这样的包被划分为命名空间包。

​	下面我们对模块搜索时的具体搜索原理进行进一步解释：

![img](file:////tmp/wps-achui/ksohtml/wpsEhwpMA.jpg) 

​	通过上面的原理我们可以知道，如果我们显示的添加了__init__.py文件在导入包的过程中是有优化作用的，同时也知道如果我们使用命名空间包导入的话，在搜索路径中应该避免出现同名的结束标志，否则命名空间包的导入时不会生效的。

同时应了解到__init__.py文件可以为空，它在包第一次被加载时会运行。

### ***\*5\*******\*.5.2\**** ***\*几种包导入的形式\****

#### ***\*5\*******\*.5.2.1\**** ***\*包导入\****

在常规的包导入中，我们直接使用import或者from配合点号分割符，即可完成导入操作。这个与模块导入是相同的。例子如下所示：

模块目录结构如下

dir0/dir1/dir2/module_name.py

导入模块语句应为

import dir1.dir2.module_name

注意事项：

dir0为包的容器，应该出现在sys.path这个列表中，这样才可以被正常加载

dir1和dir2为包，其目录下应该含有__init__.py文件作为标识（python3.3之前严格要求拥有该文件）当然该文件在教新的python版本中，也可以没有，作为命名空间包，也是支持这样进行导入的

dir0下有没有__init__.py不重要，解释器不会关注

#### ***\*5\*******\*.5.2.2\**** ***\*包相对导入\****

在包内部，如果导入同一个包中的内容时，可以不像包导入中那样，将容器之下的路径明确指明，我们可以通过from语句来实现同包内的相对导入机制。示例如下所示：（注意：相对导入只会搜索包目录，而绝对导入搜索sys.path不会搜索包目录，在python3中）

在包内既可以使用相对路径也可以使用绝对路径来导入模块，当然这种相对导入只使用于同一个包下，如果是一个容器下的两个包，是不适用的，

![img](file:////tmp/wps-achui/ksohtml/wpsTP9XbA.jpg) 

#### ***\*5\*******\*.\*******\*5\*******\*.2.3\**** ***\*命名空间包导入\****

命名空间包的导入机制可以让我们横跨多个目录导入在不同目录下的模块或者包，不过使用时应该参考5.5.1中的注意事项，具体实例如下所示：

![img](file:////tmp/wps-achui/ksohtml/wps9uw99A.jpg) 