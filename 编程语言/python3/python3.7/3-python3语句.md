# 3 Python3语句

前面的内容主要介绍了内置的对象类型以及一些运算符，通过这些基本的方式，我们可以组合成表达式，而表达式又可以组成语句，这一章我们主要介绍各种语句结构（语句使用并引导表达式处理对象）。

前面我们其实已经学习了大量的语句结构，如del，赋值语句等，这一章我们将学习一些常见的语句和复合语句的用法。

## 3.1 常见的语句

### 3.1.1 赋值语句

前面我们主要学习了，基本的赋值操作`=`，通过赋值操作我们可以为变量添加对象引用，也可以实现多变量同时赋值，在此基础上还可以实现，元组列表的解包操作

#### 扩展解包详解

扩展序列解包的使用（*号的使用），使用如下所示：

![img](file:////tmp/wps-achui/ksohtml/wpsDefBAA.jpg) 

​	星号所在项会把解出的值放入一个列表当中去，解包操作不止针对元组列表而然，对于可迭代对象也是可以操作的。

![img](file:////tmp/wps-achui/ksohtml/wpsQ0EkeB.jpg) 

​	针对解包时*所在项未解析到元素，则会形成空列表：

![img](file:////tmp/wps-achui/ksohtml/wpse6SuJx.jpg) 

​	解包时常见的错误和注意事项如下所示：

![img](file:////tmp/wps-achui/ksohtml/wpsvNMBAA.jpg) 

​	在for循环中使用扩展解包：

![img](file:////tmp/wps-achui/ksohtml/wpsvv1JkA.jpg) 

#### ***\*3\*******\*.1.1.2\**** ***\*使用_接收废弃结果\****

在我们编写程序的过程中，总是会接收没有用的返回值，可以用一个特殊的变量去引用这些没有用的对象，类似linux中的/dev/null。这个变量名名为_。

### ***\*3\*******\*.1.2\**** ***\*推导式\****

推导源自数学集合的概念，它是一种通过对序列中的每一项运行一个表达式来创建一个新的集合的方法。每次一个，从左到右。推导是一种处理序列的方法，我们这里简单的介绍几种常用的推导方法。

#### ***\*3\*******\*.1.2.1\**** ***\*列表推导式\****

##### ***\*3\*******\*.1.2.1.1\**** ***\*基本的推导式格式\****

将推导的表达式放入一个方括号中，即可生成一个列表推导式。

![img](file:////tmp/wps-achui/ksohtml/wpswKhRqB.jpg) 

方括号中的内容，看起来像一个for迭代工具的反向书写，列表推导式的基本格式如下(过滤条件可有可无)

[expr for value in collection ifcondition]

它跟for迭代工具实现的代码是同一个效果，但是他底层由C语言编写，速度更快。

![img](file:////tmp/wps-achui/ksohtml/wps0HWLWz.jpg) 

​	所以for迭代上下文工具，能够实现的简单操作，都可以是用推导式来完成。

##### ***\*3\*******\*.1.2.1.2\**** ***\*扩展的推导式格式\****

推导式当中的for迭代工具后面可以跟一个条件筛选分句，如下所示：

![img](file:////tmp/wps-achui/ksohtml/wpsUdUiMB.jpg) 

​	上述例子我们通过条件筛选将3排除在了我们生成的列表之外。

​	推导式当中可以支持无限次的for分句，并且每个for分句后面都可以衔接一个if分句，但是通常太多的for嵌套将导致程序难以理解，此时不推荐使用推导式。

![img](file:////tmp/wps-achui/ksohtml/wpshqG9NA.jpg) 

#### ***\*3\*******\*.1.2.2\**** ***\*字典推导式\****

字典推导，就是将生成列表推导的方括号换成{}，其中的表达式要使用冒号指定键值对的对应关系，其他推导语法都是适用的，如下所示：

![img](file:////tmp/wps-achui/ksohtml/wps1RR1Cy.jpg) 

#### ***\*3\*******\*.1.2.3\**** ***\*集合推导式\****

集合推导式就是将列表推导式的[]换为{}即可，如下图所示：

![img](file:////tmp/wps-achui/ksohtml/wpsy1LVhz.jpg) 

#### ***\*3\*******\*.1.2.4\**** ***\*元组推导式\****

元组推导式跟其他推导式并无语法上的大的差别，只需要将[]换为()即可，但是元组推导式生成的结果并不是列表，字典，元组等，而是生成器，关于生成器的内容可以到生成器章节查看。

## 3.2 条件控制

### 3.2.1 条件控制形式

python中放弃了switch-case语句，再使用if语句的时候，需要灵活多变，可以各种嵌套，根据自己的经验来，下面只是一些基本的语法格式。

#### ***\*3.2.1.1 单if\****

![img](file:////tmp/wps-achui/ksohtml/wps4LVMgz.jpg) 

#### ***\*3.2.1.2 if-else形式\****

![img](file:////tmp/wps-achui/ksohtml/wpsW9jmlz.jpg) 

每条if都会被执行，如果都不足就执行，else。

#### ***\*3.2.1.3 if-elif-else形式\****

![img](file:////tmp/wps-achui/ksohtml/wpse6mtUB.jpg) 

If满足，就不在执行后面的代码，否则执行，elif，他也不满足，就执行，else。

#### ***\*3.2.1.4 省略else形式\****

![img](file:////tmp/wps-achui/ksohtml/wpsIHOXvx.jpg) 

如果某一条满足，余下的就不会被执行。

#### ***\*3.2.1.5 多条件测试\****

![img](file:////tmp/wps-achui/ksohtml/wpsG3XpVy.jpg) 

这里的每个if都会被执行一遍。

#### ***\*3\*******\*.2.1.6\**** ***\*三元表达式\****

![img](file:////tmp/wps-achui/ksohtml/wpsQtyHyy.jpg) 

## ***\*3.3 循环语句\****

python中没有，do...while循环。

### ***\*3.3.1 while循环\****

基本语法形式如下所示（while…else）

![img](file:////tmp/wps-achui/ksohtml/wpscz1PJA.jpg) 

### ***\*3.3.\*******\*2\**** ***\*break和continue\****

break语句和continue语句只有在循环语句中才会生效，break表示终止循环，而continue语句表示跳出本次循环执行下次循环。

### ***\*3\*******\*.3.3 pass\*******\*语句\****

pass语句在pass中是一个占位语句，不做任何事情，单纯的用来保证其他复杂语句的完整性。

### ***\*3.3.\*******\*4\**** ***\*for循环\****

​	for循环在python中是一个通用的序列迭代工具，它可以遍历任何有序序列或其他可迭代对象内的元素。（for语句可用于字符串，列表，元组或其他内置可迭代对象）

![img](file:////tmp/wps-achui/ksohtml/wpsfbQbpx.jpg) 

​	当python运行for循环时，会逐个将可迭代对象中的元素赋值给for后出现的名称，然后为每个元素执行循环主体。主体中通过赋值的元素引用对象。

for之后也可以使用类似while...else那种结构，注意事项是一致的。

### ***\*3\*******\*.3.5 zip\*******\*函数\****

Zip这个内置的函数，参数列表接收一个或多个序列，而他的返回值是一个序列并排元素组成的可迭代对象。

![img](file:////tmp/wps-achui/ksohtml/wpstVGpJz.jpg) 

​	通过zip我们还可以构建字典：

![img](file:////tmp/wps-achui/ksohtml/wpsCwIlRz.jpg) 

### ***\*3\*******\*.3.6 enumerate\*******\*函数\****

该函数在使用时可以将序列或者可迭代对象的索引和值同时给出：

![img](file:////tmp/wps-achui/ksohtml/wpscD1y0x.jpg) 

## ***\*3.5 迭代器和生成器\****

### ***\*3.5.1 可迭代的对象\****

如果对象是实际保存的序列（如列表等）或是可以在迭代工具（for循环，列表推导，in成员关系测试，内置函数map等）上下文中一次产生一个结果的对象，那么就可以看做是可迭代的，也可以被称为可迭代对象。可以查看以下示例：

![img](file:////tmp/wps-achui/ksohtml/wpsxn4aKB.jpg) 

### ***\*3\*******\*.5.2\**** ***\*迭代协议\****

1）首先python3中有两个内置的函数next()函数和iter()函数，分别可以调用对象内部的__next__和__iter__方法。（在python2.x中迭代器对象的内置方法为next()方法，而python3.x中迭代器对象的方法为__next__()方法，所以python为了兼容两种版本的迭代方式，给出了next()内置方法，它在python2.x中调用next(),在python3.x中调用__next__()）

2）所有拥有__next__方法的对象，在调用该方法时，会前进到下一个结果，而当到达一系列结果的末尾时，__next__会引发StopIteration异常，而没有__next__方法的对象，其内部的__iter__方法，可被iter()函数所调用，返回的对象包含__next__方法，进而可以像拥有__next__方法的对象一样，进行相关操作，这种调用形式被称为迭代协议。

### ***\*3.5.3\**** ***\*迭代器对象\****

#### ***\*3\*******\*.5.3.1\**** ***\*迭代器对象\****

在迭代协议中，本身拥有__next__方法对象和通过iter()方法调用生成的具有__next__方法的对象，在python中被称为迭代器对象。这类对象也能通过迭代工具进行遍历，因为所有迭代工具内部工作起来都是在每次迭代中调用__next__方法，并且通过捕获StopIteration异常，来确定何时离开。本身是迭代器的对象在迭代上下文工具中调用iter()函数时，这步相当于空操作。

#### ***\*3\*******\*.5.3.2\**** ***\*迭代器对象和可迭代对象的关系\****

迭代器对象本身就是可迭代对象，而可迭代对象可以通过iter()函数去生成临时的迭代器对象。

不是迭代器对象的可迭代对象有一个好处，是可以进行多遍迭代，而不像本身是迭代器对象的对象在同一命名空间中只支持单遍迭代。

![img](file:////tmp/wps-achui/ksohtml/wpsUTbcDy.jpg) 

#### ***\*3\*******\*.5.3.3\**** ***\*判断迭代器对象和可迭代对象\****

![img](file:////tmp/wps-achui/ksohtml/wpsNjqZOz.jpg) 

#### ***\*3\*******\*.5.3.4\**** ***\*迭代器的好处\****

![img](file:////tmp/wps-achui/ksohtml/wpsvqnvnB.jpg) 

### ***\*3.5.4\**** ***\*迭代上下文工具\****

迭代上下文工具的作用自动实现迭代协议，如一个可迭代对象是列表类型，在for中，首先会调用iter()函数，返回临时迭代器对象，然后调用__next__方法去依次获取结果。

### ***\*3.5.5\**** ***\*生成器\****

在python中，生成器对象用法就像迭代器对象一样，但是它能够自动的支持迭代协议，生成器的实现通常分为两种，一种是生成器函数，另一种是生成器表达式。

生成器函数使用常规的def语句进行编写，但是他不使用return返回值，而采用yield语句一次返回一个结果，在每次结果产生之间挂起和恢复它们的状态。

![img](file:////tmp/wps-achui/ksohtml/wps0LuVFz.jpg) 

​	生成器表达式，就是我们所说的元组推导式，它返回一个生成器对象，自动实现了迭代协议，可以被迭代上下文工具进行迭代。

![img](file:////tmp/wps-achui/ksohtml/wpsBd7jLy.jpg) 

## ***\*3.\*******\*6\**** ***\*函数\****

### ***\*3\*******\*.6.1\**** ***\*函数的基本概念\****

#### ***\*3\*******\*.6.1.1\**** ***\*函数的基本定义\****

1）函数就是将一些语句集合在一起的组件，从而让它们能够不止一次的在程序中运行，达到代码复用的目的，函数中可以指定输入（传参），以及返回一个计算结果（返回值）。

2）函数是python为了达到代码重用最大化而提供的最基本的程序结构。

3）函数中涉及到的关键字，声明函数的方式（def和lambda）,两种管理作用域的方式（global和nonlocal）,以及两种传回返回值的方式（return和yield）。

4） 函数增加了一个额外的命名空间层来最小化相同变量名之间的潜在冲突。在这句话的含义就是def内定义的变量只能def内的代码使用。

5）Python内置了很多有用的函数，如len()函数等，而内置函数我们只需要关注他的用法即可，既该传入什么值，应返回什么值。本节的主要侧重点在于如何实现自定义函数。

6）def语句是一个可执行的语句，在python运行def之前，函数是并不存在的，并且def语句是可以嵌入到if,while等语句中的，甚至是可以嵌入到def语句中，def语句在创建函数时，本质上是创建一个对象并将其赋值给某一个变量（函数名）。

#### ***\*3\*******\*.6.1.2\**** ***\*函数的基本语法定义与调用\****

函数的基本语法形式如下，[]括号中的内容代表可选项：

![img](file:////tmp/wps-achui/ksohtml/wpsME9JaA.jpg) 

​	调用函数的基本语法是函数名后增加括号调用这个函数，括号中可以包含一个或多个对象参数。

[返回值] = 函数名([形参值])

#### ***\*3.\*******\*6\*******\*.\*******\*1\*******\*.3\**** ***\*return关键字\****

​	在函数中return用于退出函数并返回一个表达式，如果return语句没有显示的表达式，则默认返回None类型，这种情况下我们可以将return也一起省略掉。

![img](file:////tmp/wps-achui/ksohtml/wpsNDP3Iy.jpg) 

通常情况下，一个函数只有一个返回值，实际上 Python 也是如此，只不过 Python 函数能以返回列表或者元组的方式，将要返回的多个值保存到序列中，从而间接实现返回多个值的目的。实现 Python 函数返回多个值，有以下 2 种方式：

1）在函数中，提前将要返回的多个值存储到一个列表或元组中，然后函数返回该列表或元组；

2）函数直接返回多个值，之间用逗号（ , ）分隔，Python 会自动将多个值封装到一个元组中，其返回值仍是一个元组。

### ***\*3\*******\*.6.2\**** ***\*作用域\****

#### ***\*3\*******\*.6.2.1\**** ***\*作用域的简介\****

1）作用域能阻止程序代码中的名称冲突（既变量名冲突）。

2）在源代码中变量名被赋值的位置决定了这个变量命能被访问到的范围。

3）python中的作用域结构大致如下所示：

![img](file:////tmp/wps-achui/ksohtml/wpsFy9vTB.jpg) 

#### ***\*3\*******\*.6.2.2 LEGB\*******\*规则\****

在函数中使用未限定（没有显示的指明它所处的作用域）的变量名时，python将查找4个作用域，并将在第一次找到该变量名的地方停下来LNGB原则（local （局部作用域）-> nonlocal（非局部作用域） -> global（全局作用域） -> builtins（内置作用域））

![img](file:////tmp/wps-achui/ksohtml/wpsxWUDoy.jpg) 

内置作用域中的内置函数，可以通过LEGB原则，自动的获得，而不需要显示的指定，但是也可以通过builtins模块手动的导入（通常这涉及到一些更高级的话题，我们在这里不进行讨论和深究）。

 

#### ***\*3\*******\*.6.2.3 global\*******\*和n\*******\*onlocal\****

对于变量我们可以根据LEGB原则自动搜索，也可以在使用的地方显示的使用global和nonlocal声明它的作用域，比如在一个嵌套函数的内容，我们使用一个global声明一个变量，它指代的就是模块文件顶层的全局变量。而在内层函数中使用nonlocal声明一个变量它指代的就是外层函数的非局部变量。

![img](file:////tmp/wps-achui/ksohtml/wps1k9pDy.jpg) 

​	Global和nonloacl的显示声明，使我们在引用的基础上可以更改声明的变量的值。在使用时应该注意，global允许声明不存在的变量名，而nonloacl声明的变量名必须已经在外层函数中存在。

#### ***\*3\*******\*.6.2.4\**** ***\*闭包（工厂函数）\****

闭包就是在嵌套函数的基础上，返回内部函数，而内部函数可以被动态的创建并记录外部函数的值。（用比较容易懂的人话说，就是当某个函数被当成对象返回时，夹带了外层函数的变量，于是就形成了一个闭包。）

闭包需要满足以下几点内容：

1）外部函数中定义了内部函数；

2）外部函数是有返回值的；

3）返回的值是，内部函数名；

4）内部函数引用了外层函数的变量。

简单的闭包实现如下所示：

![img](file:////tmp/wps-achui/ksohtml/wps3RP2Wz.jpg) 

闭包可以通过内部函数记录外部函数的值，如下所示：

![img](file:////tmp/wps-achui/ksohtml/wpsbqcOqy.jpg) 

由于闭包可以记录外层函数中变量的特性，所以它可以完成一些需要类实现的功能。以下为闭包函数实现计数器功能示例：

![img](file:////tmp/wps-achui/ksohtml/wpsmVC4Wz.jpg) 

### ***\*3.\*******\*6\*******\*.3 函数参数解析\****

#### ***\*3.\*******\*6\*******\*.3.1\**** ***\*形参和实参\****

通常情况下，定义函数时都会选择有参数的函数形式，函数参数的作用是传递数据给函数，令其对接收的数据做具体的操作处理。在使用函数时，经常会用到形式参数（简称“形参”）和实际参数（简称“实参”），二者都叫参数，之间的区别是：

1）形式参数：在定义函数时，函数名后面括号中的参数就是形式参数；

2）实际参数：在调用函数时，函数名后面括号中的参数称为实际参数，也就是函数的调用者给函数的参数。

![img](file:////tmp/wps-achui/ksohtml/wps91UvXA.jpg) 

函数的参数名和调用者传递的变量名是互不冲突的（因为作用域不同，所以互不影响，简单来说可以同名）。

#### ***\*3.\*******\*6\*******\*.3.2\**** ***\*值传递和引用传递\****

参数传递的本质：参数的传递时通过将对象赋值给局部变量名实现的（即变量的共享引用）

![img](file:////tmp/wps-achui/ksohtml/wpsMnp4gz.jpg) 

​	针对不可变的数据类型的对象，在函数内部进行原位置修改，赋值等操作时会破坏这种引用关系，所以看起来像是传递参数时将实参的值传递了给形参，所以叫做值传递，而引用传递针对的是可变类型的数据，支持原位置修改对象内容。

#### ***\*3.\*******\*6.3\*******\*.3\**** ***\*参数的传递形式\****

在python中形参和实参的对应方式有多种类型，如下所示：

1）***\*位置参数\****：实参和形参从左到右依次对应

![img](file:////tmp/wps-achui/ksohtml/wps1DV2Dx.jpg) 

​	2）***\*关键字参数：\****调用者在调用函数时,显示的指定实参与形参的对应关系

![img](file:////tmp/wps-achui/ksohtml/wpsZBlmjz.jpg) 

3）***\*默认参数：\****在定义函数的时候，可以给形参定义一个默认值，这样，在调用函数的时候，即使没有传递实参，函数也会直接使用默参数值。（在使用此格式定义函数时，指定有默认值的形式参数必须在所有没默认值参数的最后，否则会产生语法错误）

![img](file:////tmp/wps-achui/ksohtml/wpsOzoPnB.jpg) 

Pyhton 中，可以使用“函数名.__defaults__”查看函数的默认值参数的当前值，其返回值是一个元组。

***\*4）不定长参数\****：即传入函数中的实际参数可以是任意多个。示例如下所示：

![img](file:////tmp/wps-achui/ksohtml/wpsvfa1bA.jpg) 

​	不定长的参数实现的方式主要是两种，一种是*形式，另一种是**形式，*形式将接收的参数，变成元组的形式，而**形式接收的是关键字类型的参数，将其变为字典形式。它们的默认值是空元组和空字典。**这种形式的参数在形参和实参中都必须写在最后。

***\*5）逆向参数收集：\****Python 的逆向参数收集，即直接将列表、元组、字典作为函数参数，Python 会将其进行拆分，把其中存储的元素按照次序分给函数中的各个形参。在以逆向参数收集的方式向函数参数传值时，Pyhon 语法规定，当传入列表或元组时，其名称前要带一个 * 号，当传入字典时，其名称前要带有 2 个 * 号（如果传参时其列表名前不带 * 号，则 Python 解释器会将整个列表作为参数传递给一个参数）。

![img](file:////tmp/wps-achui/ksohtml/wps47ek9y.jpg) 

#### ***\*3\*******\*.6.3.4\**** ***\*函数注解\****

为函数中的形参和返回值提供类型提示信息。给函数中的参数做注解的方法是在形参后添加冒号“：”，后接需添加的注解（可以是类（如 str、int 等），也可以是字符串或者表示式）；给返回值做注解的方法是将注解添加到 def 语句结尾的冒号和 -> 之间。如果参数有默认值，参数注解位于冒号和等号之间。

![img](file:////tmp/wps-achui/ksohtml/wpseUtruy.jpg) 

![img](file:////tmp/wps-achui/ksohtml/wpsNHGJ7x.jpg) 

​	给函数定义好注解之后，可以通过函数对象的 __annotations__ 属性获取，它是一个字典，在应用运行期间可以获取。

注意，函数注解没有任何语法上的意义，只是为函数参数和返回值做注解，并在运行获取这些注解，仅此而已。换句话说，为函数做的注解，Python不做检查，不做强制，不做验证，什么操作都不做，函数注解对Python解释器没任何意义。

### ***\*3.\*******\*6\*******\*.5 匿名函数\****

#### ***\*3.\*******\*6\*******\*.5.1 匿名函数的概念\****

![img](file:////tmp/wps-achui/ksohtml/wpsClrrdy.jpg) 

Lambda创建的函数返回了函数本身而不是将其赋值给一个变量名，这也是lambda被称为匿名函数的原因。以下为lambda的实例：

![img](file:////tmp/wps-achui/ksohtml/wpseo0YXy.jpg) 

​	Lambda创建的函数跟def创建的函数作用是一致的，但是由于lambda是表达式而不是语句，所以他能够出现在def无法出现的地方。

#### ***\*3\*******\*.6.5.2\**** ***\*模拟s\*******\*witch\*******\*语句\****

![img](file:////tmp/wps-achui/ksohtml/wps6tCTsx.jpg) 

### ***\*3\*******\*.6.6\**** ***\*函数式编程工具\****

Python 允许使用变量，所以它并不是一门纯函数式编程语言。Python 仅对函数式编程提供了部分支持，主要包括 map()、filter() 和 reduce() 这 3 个函数，它们通常都结合 lambda 匿名函数一起使用。接下来就对这 3 个函数的用法做逐一介绍。

#### ***\*3.6.6.1 map\*******\*函数\****

map() 函数的基本语法格式如下：

map(function, iterable)

其中，function 参数表示要传入一个函数，其可以是内置函数、自定义函数或者 lambda 匿名函数；iterable 表示一个或多个可迭代对象，可以是列表、字符串等。
  map() 函数的功能是对可迭代对象中的每个元素，都调用指定的函数，并返回一个 map 对象。注意，该函数返回的是一个 map 对象，不能直接输出，可以通过 for 循环或者 list() 函数来显示。

![img](file:////tmp/wps-achui/ksohtml/wps19o03z.jpg) 

#### ***\*3.6.6\*******\*.\*******\*2 filter\*******\*函数\****

filter()函数的基本语法格式如下：

filter(function, iterable)

此格式中，funcition 参数表示要传入一个函数，iterable 表示一个可迭代对象。filter() 函数的功能是对 iterable 中的每个元素，都使用 function 函数判断，并返回 True 或者 False，最后将返回 True 的元素组成一个新的可遍历的集合。（filter() 函数可以接受多个可迭代对象。）

![img](file:////tmp/wps-achui/ksohtml/wpsv14hWx.jpg) 

#### ***\*3\*******\*.6.6.3 reduce\*******\*函数\****

reduce() 函数通常用来对一个集合做一些累积操作，其基本语法格式为：

reduce(function, iterable)

其中，function 规定必须是一个包含 2 个参数的函数；iterable 表示可迭代对象。
  注意，由于 reduce() 函数在 Python 3.x 中已经被移除，放入了 functools 模块，因此在使用该函数之前，需先导入 functools 模块。

![img](file:////tmp/wps-achui/ksohtml/wpseb5B5A.jpg) 