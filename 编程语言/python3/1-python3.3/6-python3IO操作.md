# **4** ***\*Python3 IO\****

当程序运行时，对象中存储的数据是暂时的，程序结束后就会丢失，如果希望程序结束后数据仍然保持，就需要将数据保存到文件中，Python提供了内置的文件对象，以及对文件、目录进行操作的内置模块，通过这些技术可以很方便地将数据保存到文件（如文本文件等）中。

## ***\*6\*******\*.1\**** ***\*文件内容操作\****

通常在计算机操作一个文件，分别为如下步骤：

![img](file:////tmp/wps-achui/ksohtml/wpsAHMkPz.jpg) 

Python中提供了open内置函数去打开文件，而打开的文件被映射为一个文件对象，提供了read,write,close方法，用于我们对于文件的操作。

### ***\*6.1.1\**** ***\*生成文件对象\****

#### ***\*6\*******\*.1.1.1 open\*******\*函数的基本语法格式\****

Python内置函数open能够创建一个python文件对象作为到计算机上一个文件的链接，在调用open之后，可以通过返回的文件对象，去操作文件。

open()函数的常用语法格式如下：

file = open(file_name [, mode='r' [ , buffering=-1 [ , encoding = None ]]])

此格式中，用 [] 括起来的部分为可选参数，即可以使用也可以省略。其中，各个参数所代表的含义如下：

1）file：表示要创建的文件对象。要创建或打开文件的文件名称，该名称要用引号（单引号或双引号都可以）括起来。需要注意的是，如果要打开的文件和当前执行的代码文件位于同一目录，则直接写文件名即可；否则，此参数需要指定打开文件所在的完整路径。

2）mode：可选参数，用于指定文件的打开模式。如果不写，则默认以只读（r）模式打开文件。

3）buffing：可选参数，用于指定对文件做读写操作时，是否使用缓冲区。

4）encoding：手动设定打开文件时所使用的编码格式，不同平台的 ecoding 参数值也不同，以 Windows 为例，其默认为 cp936（实际上就是 GBK 编码），一般我们常用的utf-8编码。

#### ***\*6\*******\*.1.1.2 open\*******\*中的m\*******\*ode\****

![img](file:////tmp/wps-achui/ksohtml/wpszxxnly.jpg) 

#### ***\*6\*******\*.1.1.3\**** ***\*文件缓存区\****

通常情况下，不需要修改 buffing 参数的值，既使用默认的缓存区。

如果 buffing 参数的值为 0（或者 False），则表示在打开指定文件时不使用缓冲区；如果 buffing 参数值为大于 1 的整数，该整数用于指定缓冲区的大小（单位是字节）；如果 buffing 参数的值为负数，则代表使用默认的缓冲区大小。（使用缓冲区，则程序在执行输出操作时，会先将所有数据都输出到缓冲区中，然后继续执行其它操作，缓冲区中的数据会有外设自行读取处理；同样，当程序执行输入操作时，会先等外设将数据读入缓冲区中，无需同外设做同步读写操作）

### ***\*6\*******\*.1.2\**** ***\*读取文本文件对象数据\****

当前文件对象数据的读取最佳实现是使用迭代工具去读取，而非使用文件对象自身的read方法，因为文件对象是一个迭代器对象。但是我们这里依旧要介绍下文件对象的操作方法，因为其他的程序员可能会使用这些方法。

![img](file:////tmp/wps-achui/ksohtml/wps9EOavx.jpg) 

[Python](http://c.biancheng.net/python/) 提供了如下 3 种函数，它们都可以帮我们实现读取文件中数据的操作：

1）read() 函数：逐个字节或者字符读取文件中的内容；

2）readline() 函数：逐行读取文件中的内容；

3）readlines() 函数：一次性读取文件中多行内容。

#### ***\*6\*******\*.1.2.1 read\*******\*函数\****

如果文件是以文本模式（非二进制模式）打开的，则 read() 函数会逐个字符进行读取；反之，如果文件以二进制模式打开，则 read() 函数会逐个字节进行读取。

read() 函数的基本语法格式如下：

file.read([size])

其中，file 表示已打开的文件对象；size 作为一个可选参数，用于指定一次最多可读取的字符（字节）个数，如果省略，则默认一次性读取所有内容。size 表示的是一次最多可读取的字符（或字节）数，因此，即便设置的 size 大于文件中存储的字符（字节）数，read() 函数也不会报错，它只会读取文件中所有的数据。

#### ***\*6\*******\*.1.2.2 read\*******\*line函数\****

readline() 函数用于读取文件中的一行，包含最后的换行符“\n”。此函数的基本语法格式为：

file.readline([size])

其中，file 为打开的文件对象；size 为可选参数，用于指定读取每一行时，一次最多读取的字符（字节）数。和 read() 函数一样，此函数成功读取文件数据的前提是，使用 open() 函数指定打开文件的模式必须为可读模式（包括 r、rb、r+、rb+ 4 种）。

#### ***\*6\*******\*.1.2.3 read\*******\*lines函数\****

readlines() 函数用于读取文件中的所有行，它和调用不指定 size 参数的 read() 函数类似，只不过该函数返回是一个字符串列表，其中每个元素为文件中的一行内容。和 readline() 函数一样，readlines() 函数在读取每一行时，会连同行尾的换行符一块读取。

### ***\*6\*******\*.1.3\**** ***\*写入文件内容\****

#### ***\*6\*******\*.1.3.1 write\*******\*函数\****

[Python](http://c.biancheng.net/python/) 中的文件对象提供了 write() 函数，可以向文件中写入指定内容。该函数的语法格式如下：

file.write(string)

其中，file 表示已经打开的文件对象；string 表示要写入文件的字符串（或字节串，仅适用写入二进制文件中）。注意，在使用 write() 向文件中写入数据，需保证使用 open() 函数是以 r+、w、w+、a 或 a+ 的模式打开文件，否则执行 write() 函数会抛出 io.UnsupportedOperation 错误。

#### ***\*6\*******\*.1.3.2 writelins\*******\*函数\****

writelines() 函数，可以实现将字符串列表写入文件中，需要注意的是，使用 writelines() 函数向文件中写入多行数据时，不会自动给各行添加换行符。

### ***\*6\*******\*.1.4\**** ***\*关闭文件\****

close() 函数是专门用来关闭已打开文件的，文件在打开并操作完成之后，就应该及时关闭，否则程序的运行可能出现问题。其语法格式也很简单，如下所示：

file.close()

当然在某些实际场景中，我们可能需要在将数据成功写入到文件中，但并不想关闭文件。这也是可以实现的，调用 flush() 函数即可。

### ***\*6\*******\*.1.5\**** ***\*文件指针\****

我们知道，使用 open() 函数打开文件并读取文件中的内容时，总是会从文件的第一个字符（字节）开始读起。那么，有没有办法可以自定指定读取的起始位置呢？答案是肯定，这就需要移动文件指针的位置。
  文件指针用于标明文件读写的起始位置。假如把文件看成一个水流，文件中每个数据（以 b 模式打开，每个数据就是一个字节；以普通模式打开，每个数据就是一个字符）就相当于一个水滴，而文件指针就标明了文件将要从文件的哪个位置开始读起。下图简单示意了文件指针的概念。

![img](file:////tmp/wps-achui/ksohtml/wps9PHQoy.png) 

可以看到，通过移动文件指针的位置，再借助 read() 和 write() 函数，就可以轻松实现，读取文件中指定位置的数据（或者向文件中的指定位置写入数据）。

注意，当向文件中写入数据时，如果不是文件的尾部，写入位置的原有数据不会自行向后移动，新写入的数据会将文件中处于该位置的数据直接覆盖掉。

实现对文件指针的移动，文件对象提供了 tell() 函数和 seek() 函数。tell() 函数用于判断文件指针当前所处的位置，而 seek() 函数用于移动文件指针到文件的指定位置。

#### ***\*6\*******\*.1.5\*******\*.\*******\*1 tell\*******\*函数\****

tell() 函数的用法很简单，其基本语法格式如下：

file.tell()

当程序使用文件对象读写数据时，文件指针会自动向后移动：读写了多少个数据，文件指针就自动向后移动多少个位置。

#### ***\*6\*******\*.1.5\*******\*.\*******\*2\**** ***\*seek函数\****

seek() 函数用于将文件指针移动至指定位置，该函数的语法格式如下：

file.seek(offset[, whence])

其中，各个参数的含义如下：

1）file：表示文件对象；

2）whence：作为可选参数，用于指定文件指针要放置的位置，该参数的参数值有 3 个选择：0 代表文件头（默认值）、1 代表当前位置、2 代表文件尾。

3）offset：表示相对于 whence 位置文件指针的偏移量，正数表示向后偏移，负数表示向前偏移。例如，当whence == 0 &&offset == 3（即 seek(3,0) ），表示文件指针移动至距离文件开头处 3 个字符的位置；当whence == 1 &&offset == 5（即 seek(5,1) ），表示文件指针向后移动，移动至距离当前位置 5 个字符处。

注意，当 offset 值非 0 时，[Python](http://c.biancheng.net/python/) 要求文件必须要以二进制格式打开，否则会抛出 io.UnsupportedOperation 错误。

## ***\*6\*******\*.2\**** ***\*文件操作\****

通常文件操作是通系统进程进行的，但是我们也可以依托于python程序提供的os模块进行文件和目录相关的操作。

remove函数用于删除文件，rename函数用户重命名。具体的操作可以查看os模块的相关说明。

 

## ***\*6.3 with/as\*******\*语句\****

### ***\*6\*******\*.3.1 with\*******\*/\*******\*as\*******\*语句\****

介绍文件操作时，一直强调打开的文件最后一定要关闭，否则会程序的运行造成意想不到的隐患。但是，即便使用 close() 做好了关闭文件的操作，如果在打开文件或文件操作过程中抛出了异常，还是无法及时关闭文件。（其实通过异常中的try/finally语句是可以关闭的）

为了更好地避免此类问题，不同的编程语言都引入了不同的机制。在[Python](http://c.biancheng.net/python/)中，对应的解决方式是使用with as 语句操作上下文管理器（context manager），它能够帮助我们自动分配并且释放资源。上下文管理器可以看做是try/finally的替代方案，它更简洁。

with as 语句的基本语法格式为：

with 表达式 [as target]：
  代码块

此格式中，用 [] 括起来的部分可以使用，也可以省略。其中，target 参数用于指定一个变量，该语句会将 expression 指定的结果保存到该变量中。

### ***\*6\*******\*.3.2\**** ***\*上下文管理器对象\****

With能操作的对象是上下文管理器对象，什么是上下文管理器对象，简单的理解，同时包含 __enter__() 和 __exit__() 方法的对象就是上下文管理器。

__enter__(self)：进入上下文管理器自动调用的方法，该方法会在 with as 代码块执行之前执行。如果 with 语句有 as子句，那么该方法的返回值会被赋值给 as 子句后的变量；该方法可以返回多个值，因此在 as 子句后面也可以指定多个变量（多个变量必须由“()”括起来组成元组）。

__exit__（self, exc_type, exc_value, exc_traceback）：退出上下文管理器自动调用的方法。该方法会在 with as 代码块执行之后执行。如果 with as 代码块成功执行结束，程序自动调用该方法，调用该方法的三个参数都为 None：如果 with as 代码块因为异常而中止，程序也自动调用该方法，使用 sys.exc_info 得到的异常信息将作为调用该方法的参数。从图示代码中我们发现文件对象即是迭代器对象，也是上下文管理器对象。

![img](file:////tmp/wps-achui/ksohtml/wpseHLOQx.jpg) 

当 with as 操作上下文管理器时，就会在执行语句体之前，先执行上下文管理器的 __enter__() 方法，然后再执行语句体，最后执行 __exit__() 方法。

常见构建上下文管理器的方式有 2 种，分别是基于类实现和基于生成器实现。

## ***\*6.4 eval\*******\*和e\*******\*xec\*******\*函数\****

eval() 和 exec() 函数都属于 [Python](http://c.biancheng.net/python/) 的内置函数，由于这两个函数在功能和用法方面都有相似之处，eval() 和 exec() 函数的功能是相似的，都可以执行一个字符串形式的 Python 代码（代码以字符串的形式提供），相当于一个 Python 的解释器。二者不同之处在于，eval() 执行完要返回结果，而 exec() 执行完不返回结果。

eval() 函数的语法格式为：

eval(expression, globals=None, locals=None, /)

exec() 函数的语法格式如下：

exec(expression, globals=None, locals=None, /)

可以看到，二者的语法格式除了函数名，其他都相同，其中各个参数的具体含义如下：

expression：这个参数是一个字符串，代表要执行的语句 。该语句受后面两个字典类型参数 globals 和 locals 的限制，只有在 globals 字典和 locals 字典作用域内的函数和变量才能被执行。

globals：这个参数管控的是一个全局的命名空间，即 expression 可以使用全局命名空间中的函数。如果只是提供了 globals 参数，而没有提供自定义的 __builtins__，则系统会将当前环境中的 __builtins__ 复制到自己提供的 globals 中，然后才会进行计算；如果连 globals 这个参数都没有被提供，则使用 Python 的全局命名空间。

locals：这个参数管控的是一个局部的命名空间，和 globals 类似，当它和 globals 中有重复或冲突时，以 locals 的为准。如果 locals 没有被提供，则默认为 globals。

## ***\*6.5\**** ***\*使用p\*******\*ython\*******\*模块持久化数据\****

通常持久化数据利用数据库来实现，这里我们将要介绍的是不依赖数据库实现数据的持久化。在python中对象数据持久化，主要通过pickle，dbm，shelve这三个模块实现。有兴趣的可以了解下相关知识。