# 7 错误、调试和测试

## 7.1 python中的错误

### 7.1.1 错误的分类

​		编写程序时遇到的错误可大致分为 2 类，分别为**语法错误**和**运行时错误**

- 语法错误多是开发者疏忽导致的，属于真正意义上的错误，是解释器无法容忍的，因此，只有将程序中的所有语法错误全部纠正，程序才能执行;
- 运行时产生错误的情况叫做**异常(Exceptions)**当一个程序发生异常时，代表该程序在执行时出现了非正常的情况，无法再执行下去。默认情况下，程序是要终止的;

### 7.1.2 语法错误

​		通常语法错误，都会引发`SyntaxError`

```console
# 在Python3的解释器中使用python2的语法引发报错

In [1]: print "hello"
  File "<ipython-input-3-2a0eaa89f43f>", line 1
    print "hello"
          ^
SyntaxError: Missing parentheses in call to 'print'. Did you mean print("hello")?
```

### 7.1.3 异常错误

​		在运行时可以产生很多种异常错误，通常分为以下三大类，我们通常所指的异常就是第三种类型：

1.  **bug:** 有的错误是程序编写有问题造成的，比如本来应该输出整数结果输出了字符串，这种错误我们通常称之为bug，bug是必须修复的;
2.  **用户操作错误**: 有的错误是用户输入造成的，比如让用户输入email地址，结果得到一个空字符串，这种错误可以通过检查用户输入来做相应的处理;(在web开发时可以通过前端程序和后台程序分别进行验证)
3.  **异常**: 还有一类错误是完全无法在程序运行过程中预测的，比如写入文件的时候，磁盘满了，写不进去了，或者从网络抓取数据，网络突然断掉了,程序出现索引越界,变量引用时未定义等，这类错误也称为异常，在程序中通常是必须处理的，否则，程序会因为各种问题终止并退出;

## 7.2 异常

​		还记得我们介绍的tracebake记录吗，Python内置了一套异常处理机制，来帮助我们进行错误处理。如果异常只能用来显示错误消息，就没多大意思了。事实上，每个异常都是某个具体的异常类的实例。你能以各种方式引发和捕获这些实例，从而逮住错误并采取措施，而不是放任整个程序失败。这也是为什么python会给出一套完整的异常处理的工具。

​		异常中涉及到的关键字如下所示，主要包块`try`,  `except`，`else`， `finally`：

```python
    try:
        可能产生异常的代码块
    except [ (Error1, Error2, ... ) [as e] ]:
        处理异常的代码块1
    except [ (Error3, Error4, ... ) [as e] ]:
        处理异常的代码块2
    except  [Exception]:
        处理其它异常
    else:
        pass
    finally:
        pass
```
### 7.2.1 异常的正式介绍

#### 7.2.2.1异常简介

​		Python使用被称为异常的特殊对象来管理程序执行期间发生的错误，每当发生让python不知所措的错误时，他都会创建一个异常对象，如果你编写了处理异常的代码，程序将继续运行，如果你没有对异常进行处理，程序将会停止，并显示一个`traceback`,其中包含有关异常的报告。这通常不是我们想要的，如果要避免程序退出，可以使用捕获异常的方式获取这个异常的名称，再通过其他的逻辑代码让程序继续运行，这种根据异常做出的逻辑处理叫作**异常处理**。

​		高级语言通常都内置了一套`try...except...`的错误处理机制，Python也不例外。这个处理机制可以帮助我们在异常发生时，不中断程序的运行。

try except 语句的执行流程如下：

1. 首先执行 try 中的代码块，如果执行过程中出现异常，系统会自动生成一个异常类型，并将该异常提交给 Python 解释器，此过程称为**捕获异常**。

2. 当 Python 解释器收到异常对象时，会寻找能处理该异常对象的 except 块，如果找到合适的 except 块，则把该异常对象交给该 except 块处理，这个过程被称为**处理异常**。如果 Python 解释器找不到处理异常的 except 块，则程序运行终止，Python 解释器也将退出。

以下我们对异常处理语句进行一下详解：（以下内容是完整的异常格式）

![img](file:////tmp/wps-achui/ksohtml/wps8ZsNsx.jpg)

当我们认为某些代码可能会出错时，就可以用try来运行这段代码，如果执行出错，则后续代码不会继续执行，而是直接跳转至错误处理代码，即except语句块，如果执行没有出错我们就会跳转到else代码块，执行其中的内容。无论是执行出错还是执行正确，在执行完对应代码块后，如果有finally语句块，则执行finally语句块，至此，执行完毕。

![img](file:////tmp/wps-achui/ksohtml/wpsAvkgUA.jpg)

else和finally是不必要的代码块，即可以加入也可以不加到程序当中。当出现else语句时，最少要搭配一个except语句。同时else语句和finally语句应当只出现一次。

在异常处理的机制中，错误应该有很多种类，如果发生了不同类型的错误，应该由不同的except语句块处理。没错，可以有多个except来捕获不同类型的错误。同时，一个except子句可以同时处理多个异常，这些异常将被放在一个括号里成为一个元组，值得注意的是如果一个异常没有与任何的except匹配，那么这个异常将会传递给上层的try中。如果错误没有被捕获，它就会一直往上抛，最后被Python解释器捕获，打印一个错误信息，然后程序退出。所以在编写代码的时候，最好处理一个未预料到的异常对象Exception，这样做可以保证我们在没有预料到可能出现的异常情况下，程序依然可以健壮的执行下去。可预料到的错误，尽量添加到except中，让错误更加明显和细致。同时except中支持as分句，as可以获取访问异常对象自身的权限。

#### ***\*7\*******\*.2.2.2\**** ***\*异常机制\****

异常处理时大致符合下图的执行流程：

![img](file:////tmp/wps-achui/ksohtml/wps9iVbky.jpg)

​	异常类和其实例采用继承的原则在类树中搜索，相应的异常进行异常抛出，我们通过except去处理异常，或者交由python解释器的异常处理器去处理异常，从而终端程序，异常的继承体系如下所示：

![img](file:////tmp/wps-achui/ksohtml/wpsyHcemA.jpg)

​	异常只应该用于处理非正常的情况，不要使用异常处理来代替正常的流程控制。对于一些完全可预知，而且处理方式清楚的错误，程序应该提供相应的错误处理代码，而不是将其笼统地称为异常。

### ***\*7\*******\*.2.\*******\*2\**** ***\*捕获所有异常\****

通常我们在最后一个except语句中捕获所有异常，防止异常抛掷到程序最顶层已发异常管理器中断程序。捕获所有异常有以下两种方式：

![img](file:////tmp/wps-achui/ksohtml/wpsCuYgzz.jpg)

​	空的except语句可以捕获一切的异常包括，系统异常所引发的异常，而Exception可以只捕获程序本身的异常。（可以在继承的图示中了解到这一原则）

### ***\*7\*******\*.2.\*******\*3\**** ***\*r\*******\*aise\*******\*语句\****

[Python](http://c.biancheng.net/python/)允许我们在程序中手动设置异常，使用 raise 语句即可，raise语句的组成包括raise关键词和后面要引发的异常类或异常类的实例。

***\*raise [exceptionName [(reason)]]\****

其中，用 [] 括起来的为可选参数，其作用是指定抛出的异常名称，以及异常信息的相关描述。如果可选参数全部省略，则 raise 会把当前错误原样抛出；如果仅省略 (reason)，则在抛出异常时，将不附带任何的异常描述信息。也就是说，raise 语句有如下三种常用的用法：

1）raise：单独一个 raise。该语句引发当前上下文中捕获的异常（比如在 except 块中），或默认引发 RuntimeError 异常。

2）raise 异常类名称：raise 后带一个异常类名称，表示引发执行类型的异常。

3）raise 异常类名称(描述信息)：在引发指定类型的异常的同时，附带异常的描述信息。

示例如下所示：

![img](file:////tmp/wps-achui/ksohtml/wpsdXUb4x.jpg)

​	不带异常名称的raise语句或是额外数据值的raise语句可以重新引发当前异常。

![img](file:////tmp/wps-achui/ksohtml/wpsRuTk5x.jpg)

以下引用异常实例的两种方法，第一种是隐式的创建异常实例，第二种是显示的创建异常实例。

![img](file:////tmp/wps-achui/ksohtml/wps4jVAhA.jpg)

### ***\*7\*******\*.2.4\**** ***\*获取异常信息\****

#### ***\*7\*******\*.2.4.1 exc_inf\*******\*o方法\****

exc_info()方法会将当前的异常信息以元组的形式返回，该元组中包含 3 个元素，分别为 type、value 和 traceback，它们的含义分别是：

1） type：异常类型的名称，它是 BaseException 的子类（有关 [Python](http://c.biancheng.net/python/) 异常类，可阅读《[Python常见异常类型](http://c.biancheng.net/view/4593.html)》一节）

2）value：捕获到的异常实例。

3）raceback：是一个 traceback 对象。

![img](file:////tmp/wps-achui/ksohtml/wpsFoyStx.jpg)

​	通过traceback 模块的print_tb方法可以解析exc_info()结果元组中的最后一个对象所包含的信息。

![img](file:////tmp/wps-achui/ksohtml/wpsFYHxYx.jpg)

#### ***\*7\*******\*.2.4.2\**** ***\*处理异常信息时获取更多信息\****

在except中我们可以更好的获取异常信息，每种异常类型都提供了如下几个属性和方法，通过调用它们，就可以获取当前处理异常类型的相关信息：

1）args：返回异常的错误编号和描述字符串；

2）str(e)：返回异常信息，但不包括异常信息的类型；

3）repr(e)：返回较全的异常信息，包括异常信息的类型。

![img](file:////tmp/wps-achui/ksohtml/wpszBzioA.jpg)

### ***\*7\*******\*.2.5 assert\*******\*语句\****

[Python](http://c.biancheng.net/python/) assert语句，又称断言语句，可以看做是功能缩小版的 if 语句，它用于判断某个表达式的值，如果值为真，则程序可以继续往下执行；反之，Python 解释器会报 AssertionError 错误。

assert 语句的完整语法格式为：

assert 条件表达式 [,描述信息]

![img](file:////tmp/wps-achui/ksohtml/wpsO1lYNz.jpg)

### 3.1.4 断言语句

​		断言语句用于判断某个表达式的值，如果值为真，则程序可以继续往下执行；反之，Python 解释器会报 AssertionError 错误；

​		基本格式为：`assert 表达式`；

​		assert 的检查是可以被关闭的，比如在命令行模式下运行 Python 程序时，加入 -O 选项就可以使程序中的 assert 失效。assert语句通常用来进行调试，

### 3.1.4 断言语句

​		断言语句用于判断某个表达式的值，如果值为真，则程序可以继续往下执行；反之，Python 解释器会报 AssertionError 错误；

​		基本格式为：`assert 表达式`；

​		assert 的检查是可以被关闭的，比如在命令行模式下运行 Python 程序时，加入 -O 选项就可以使程序中的 assert 失效。assert语句通常用来进行调试，

## ***\*7\*******\*.3\**** ***\*程序调试\****

程序能一次写完并正常运行的概率很小，基本不超过1%。总会有各种各样的bug需要修正。有的bug很简单，看看错误信息就知道，有的bug很复杂，我们需要知道出错时，哪些变量的值是正确的，哪些变量的值是错误的，因此，需要一整套调试程序的手段来修复bug。

### ***\*7\*******\*.3.1 print()调试\****

第一种方法简单直接粗暴有效，就是用print()把可能有问题的变量打印出来看看，但是他也有他的坏处就是将来还得删掉它，想想程序里到处都是print()，运行结果也会包含很多垃圾信息，对于逻辑复杂，庞大的项目，尽量选择断言的方式进行处理。

### ***\*7\*******\*.3.2 断言调试\****

凡是用print()来辅助查看的地方，都可以用断言（assert）来替代，但是程序中如果到处充斥着assert，和print()相比也好不到哪去。不过，启动Python解释器时可以用-O参数来关闭assert。关闭后，你可以把所有的assert语句当成pass来看。下面我们来做一个实例看一下。

![img](file:////tmp/wps-achui/ksohtml/wpsyahasB.jpg)

### ***\*7\*******\*.3.3\**** ***\*logging模块调试\****

***\*通过引入l\*******\*ogging\*******\*模块来使用日志调试。\****

![img](file:////tmp/wps-achui/ksohtml/wpsKe8TTx.jpg)

***\*通过 logging.debug() 函数可以打印日志信息。\****

![img](file:////tmp/wps-achui/ksohtml/wps7Gvtzx.jpg)

***\*Logging\*******\*日志的日志级别如下所示：\****

![img](file:////tmp/wps-achui/ksohtml/wpsbC2vQx.jpg)

日志级别的好处在于，我们可以改变想看到的日志消息的优先级。比如说，向 basicConfig() 函数传入 logging.DEBUG 作为 level 关键字参数，这将显示所有级别为 DEBUG 的日志消息。当开发了更多的程序后，我们可能只对错误感兴趣，在这种情况下，可以将 basicConfig() 的 level 参数设置为 logging.ERROR，这将只显示 ERROR 和 CRITICAL 消息，跳过 DEBUG、INFO 和 WARNING 消息。

***\*通过logging.disable()可以禁用消息日志打印\****

在调试完程序后，可能并不希望所有这些日志消息出现在屏幕上，这时就可以使用 logging.disable() 函数禁用这些日志消息，从而不必进入到程序中，手工删除所有的日志调用。logging.disable() 函数的用法是，向其传入一个日志级别，它会禁止该级别以及更低级别的所有日志消息。因此，如果想要禁用所有日志，只要在程序中添加 logging.disable(logging.CRITICAL) 即可。

![img](file:////tmp/wps-achui/ksohtml/wpsD99pWA.jpg)

***\*保存日志文件\****

将日志消息输出到文件中的实现方法很简单，只需要设置 logging.basicConfig() 函数中的 filename 关键字参数即可。

![img](file:////tmp/wps-achui/ksohtml/wps7ZWYhA.jpg)

### ***\*7\*******\*.3.\*******\*4\**** ***\*其他调试方法\****

在程序开发中，我们一般借助于IDE进行开发，所以可以使用pycharm自带的调试手段，对大型项目进行调试，排错。关于IDE的调试，我们放在IDE的使用手册中讲。关于代码的调试有很多种方式可以根据你自己的喜好，选择相应的调试方法。

## ***\*7\*******\*.4 测试代码\****

编写函数或类时，还可以为其编写测试类，通过测试，可确定代码面对各种输入都能够按要求的那样工作。在我们编写测试类的时候通常用到了python的unittest模块中提供的相关工具。

测试通常分为单元测试和测试用例。

1）单元测试:用于核实函数的某个方面有没有问题。

2）测试用例:是一组单元测试，这些单元测试一起核实函数在各种情形下的行为都符合要求。

3）全覆盖式测试用例包含一整套单元测试，涵盖了各种可能的函数使用方式，对于大型项目，难以使用全覆盖式测试，所以只针对关键功能进行测试。后期大范围使用时，在进行全覆盖测试。

以下我们做一个实例：

![img](file:////tmp/wps-achui/ksohtml/wpsGxyKwA.jpg)

![img](file:////tmp/wps-achui/ksohtml/wps4trBUA.jpg)

![img](file:////tmp/wps-achui/ksohtml/wpsCp7oFz.jpg)

以上是测试单个函数的实例，有时候我们需要测试整个类中的某些方法，具体步骤跟以上类似，但是，你需要在测试的时候，将类实例化，通过对象调用这些方法，进行测试。断言方法用来核实得到的结果是否与期望的结果一致。

测试的方式有很多，我们这里只做一个简单的测试，有兴趣的朋友，可以深入的了解一下，这些关于测试方面的知识，在这里单元测试是必须掌握的知识。