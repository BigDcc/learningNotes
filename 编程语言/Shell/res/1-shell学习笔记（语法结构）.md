# shell学习笔记（一）--入门shell

## 1 shell的基本介绍

### 1.1 shell简介

- Unix刚开始只支持一种交互式shell,它是由Stephen Bourne所编写的Bourne Shell(sh);
- 1989年,GNU项目的Brian Fox吸收了大量其他用户界面的特性,编写出了一种全新的shell:
Bourne Again Shell(bash)，bash shell与Bourne Shell完全兼容;
- 随着Linux成为最流行的类Unix操作系统实现,bash shell也变成了Unix和Linux中既成事实的标准shell;

### 1.1 bash简介

1. Shell 既是一种脚本编程语言，也是一个连接内核和用户的软件(解释器)。
2. 常见的 Shell 有 sh、bash、csh、tcsh、ash 等。
3. bash shell 是 Linux 的默认 shell，免费易用，功能强大。
4. Base shell 默认的提示符是美元符号$；对于超级用户（root 用户），Bash Shell 默认的提示符是井号#。该符号表示 Shell 等待输入命令。

Shell 通过PS1和PS2两个环境变量来控制提示符格式：
PS1 控制最外层命令行的提示符格式。
PS2 控制第二层命令行的提示符格式。

新建一个文件，扩展名为sh（sh代表shell），扩展名并不影响脚本执行，见名知意就好

“#!” 是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种Shell。

作为可执行程序
将上面的代码保存为test.sh，并 cd 到相应目录：
chmod +x ./test.sh  #使脚本具有执行权限
./test.sh  #执行脚本
注意，一定要写成./test.sh，而不是test.sh。运行其它二进制的程序也一样，直接写test.sh，linux系统会去PATH里寻找有没有叫test.sh的，而只有/bin, /sbin, /usr/bin，/usr/sbin等在PATH里，你的当前目录通常不在PATH里，所以写成test.sh是会找不到命令的，要用./test.sh告诉系统说，就在当前目录找。

通过这种方式运行bash脚本，第一行一定要写对，好让系统查找到正确的解释器。

这里的"系统"，其实就是shell这个应用程序（想象一下Windows Explorer），但我故意写成系统，是方便理解，既然这个系统就是指shell，那么一个使用/bin/sh作为解释器的脚本是不是可以省去第一行呢？是的。
作为解释器参数
这种运行方式是，直接运行解释器，其参数就是shell脚本的文件名，如：
/bin/sh test.sh
/bin/php test.php
这种方式运行的脚本，不需要在第一行指定解释器信息，写了也没用。

环境变量被创建时所处的 Shell 进程称为父进程，如果在父进程中再创建一个新的进程来执行 Shell 命令，那么这个新的进程被称作 Shell 子进程。当 Shell 子进程产生时，它会继承父进程的环境变量为自己所用，所以说环境变量可从父进程传给子进程。

nologin 和 login

### 1.3 shell脚本的基本事项

#### 1.3.1 注释和解释器声明

1. 注释

   bash将以 `#` 符号开头的行视为注释， 所以我们在写shell脚本的时候，`#`代表注释

2. shebang

   shell脚本通常以shebang起始，来声明解释器

```shell
#!/bin/bash
```

> 注意事项
>
> - shebang是一个文本行,其中 `#!` 位于解释器路径之前。 
> - /bin/bash是Bash的解释器命令路径。
> - 脚本中只有第一行可以使用shebang来定义解释该脚本所使用的解释器

#### 1.3.2 shell脚本执行的两种方式

1. 将脚本名作为命令行参数

```shell
bash test.sh
```

2. 授予脚本执行权限,将其变为可执行文件

```shell
chmod a+x test.sh
./test.sh  # 可以使用脚本的相对路径或者绝对路径，此时shebang会生效
```

> 注意事项
>
> - 当没有显式的注明文件路径时，直接执行可执行文件，会报错，因为shell会在PATH这个环境变量中寻找文件的位置，找到即执行，未找到即报错`commad not found`

#### 1.3.3 换行与同行

​	shell中一条命令占据一行，脚本从上到下顺序执行；

​	使用分号`；`可以将多条命令合并在一行中；

```shell
command1
command2

command1;command2
```

### 1.4 输入输出命令

#### 1.4.1 echo

- echo 是用于终端打印的最基本命令，默认情况下, echo 在每次调用后会添加一个换行符;
- echo 会在输出文本的尾部追加一个换行符。可以使用选项 -n 来禁止这种行为;
- echo后面的文本信息支持直接打印或者使用引号包含打印，三种形式有不一样的效果

```shell
echo hello word！
双引号允许shell解释字符串中出现的特殊字符
单引号不会对其做任何解释
如果不使用引号,我们无法在 echo 中使用分号,因为分号在Bash shell中用作命令间的分隔符
```
echo

包含转义序列的字符串 " 这种形式。例如:
echo -e "1\t2\t3"



要打印彩色文本,可输入如下命令:
echo -e "\e[1;31m This is red text \e[0m"
其中 \e[1;31m 是一个转义字符串,可以将颜色设为红色, \e[0m 将颜色重新置回



其中包括:重置=0,黑色=30,红色=31,绿色=32,
黄色=33,蓝色=34,洋红=35,青色=36,白色=37



对于彩色背景,经常使用的颜色码是:重置=0,黑色=40,红色=41,绿色=42,黄色=43,
蓝色=44,洋红=45,青色=46,白色=47。

printf

printf 命令接受引用文本或由空格分隔的参数,默认情况下, printf 并不会自动添加换行符



read



### 1.5 数学计算

Bash shell使用 let 、 (( )) 和 [] 执行基本的算术操作。工具 expr 和 bc 可以用来执行高级操作

let 命令可以直接执行基本的算术操作。当使用 let 时,变量名之前不需要再添加 $

let result=no1+no2
echo $result

$ let no1++

$ let no1--

操作符 [] 的使用方法和 let 命令一样:
result=$[ no1 + no2 ]
7
在 [] 中也可以使用 $ 前缀,例如:
result=$[ $no1 + 5 ]
8
也可以使用操作符 (()) 。出现在 (()) 中的变量名之前需要加上 $ :
result=$(( no1 + 50 ))



### 1.9 文件描述符与重定向

- 文件描述符是与输入和输出流相关联的整数。最广为人知的文件描述符是 stdin 、 stdout和 stderr

- 可以将某个文件描述符的内容重定向到另一个文件描述符



- 0 —— stdin (标准输入)
- 1 —— stdout (标准输出)
- 2 —— stderr (标准错误)

## 2 变量

### 2.1 定义变量

#### 2.1.1 变量的一些注意事项

- 在定义变量时不需要指明类型，直接赋值就可以；
- 在 Bash shell 中，每一个变量的值都是字符串，无论你给变量赋值时有没有使用引号，值都会以字符串的形式存储；
- Bash shell 在默认情况下不会区分变量类型，即使你将整数和小数赋值给变量，它们也会被视为字符串；
- 可以使用 declare 关键字显式定义变量的类型，但在一般情况下没有这个需求；
- 赋值号=的周围不能有空格，因为shell中的空格加等号的形式已经被判断所占用；

#### 2.1.2 定义变量

##### 2.1.2.1 变量名的规范

Shell 变量的命名规范和大部分编程语言都一样：

- 变量名由数字、字母、下划线组成；
- 必须以字母或者下划线开头；
- 不能使用 Shell 里的关键字（通过 help 命令可以查看保留关键字）;
- 常用的惯例是在脚本中使用大写字母命名环境变量,使用驼峰命名法或小写字母命名其他变量。

##### 2.1.2.2 定于变量的语法结构

Shell 支持以下三种定义变量的方式：

```shell
variable=value
variable='value'
variable="value"
```

variable 是变量名，value 是赋给变量的值。如果 value 不包含任何空白符（例如空格、Tab 缩进等），那么可以不使用引号；如果 value 包含了空白符，那么就必须使用引号包围起来。使用单引号和使用双引号也是有区别的，以单引号`' '`包围变量的值时，单引号里面是什么就输出什么，即使内容中有变量和命令（命令需要反引起来）也会把它们原样输出。这种方式比较适合定义显示纯字符串的情况，即不希望解析变量、命令等的场景。以双引号`" "`包围变量的值时，输出时会先解析里面的变量和命令，而不是把双引号中的变量名和命令原样输出。这种方式比较适合字符串中附带有变量和命令并且想将其解析后再输出的变量定义。



查看环境变量

可以使用 env 或 printenv 命令查看当前shell中所定义的全部环境变量:

要查看其他进程的环境变量cat /proc/$PID/environ

我们可以使用 pgrep 命令获得gedit的进程ID:$ pgrep gedit



注意, var = value 不同于 var=value 。把 var=value 写成 var = value
是一个常见的错误。两边没有空格的等号是赋值操作符,加上空格的等号表示的
是等量关系测试。

### 2.2 使用变量

#### 2.2.1 引用变量

使用一个定义过的变量，只要在变量名前面加美元符号$即可，有时候变量出现在一些字符串中时，可以在引用变量时加花括号帮助解释器识别变量的边界（推荐给所有变量加上花括号{ }）

```shell
name="achui"
echo "your name is ${name} "
```

#### 2.2.2 修改变量的值

已定义的变量，可以被重新赋值，第二次对变量赋值时不能在变量名前加`$`，只有在使用变量时才能加`$`

```shell
name="achui"
echo "your name is ${name} " # your name is achui
name="bigachui"
echo "your name is ${name} "  # your name is bigachui
```

#### 2.2.3 只读变量

使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。

```shell
readonly version="10.1.1"
version="0.1" # 只读变量禁止修改，执行时会报错`bash: version: 只读变量`
```

#### 2.2.4 将命令的结果赋值给变量

Shell 支持将命令的执行结果赋值给变量，常见的有以下两种方式：

```shell
variable=`command`
variable=$(command)  # 推荐使用这种方式
```

要注意的是，$() 仅在 Bash Shell 中有效，而反引号可在多种 Shell 中使用。

#### 2.2.5 删除变量

使用 unset 命令可以删除变量，变量被删除后不能再次使用；unset 命令不能删除只读变量。

```shell
name="achui"
unset name
echo ${name}  # 输出为空，因为变量被删除了
```

### 2.3 变量的作用域

#### 2.3.1 作用域的分类

Shell 变量的作用域可以分为三种：

- 有的变量只能在函数内部使用，这叫做局部变量（local variable）；
- 有的变量可以在当前 Shell 进程中使用，这叫做全局变量（global variable）；
- 而有的变量还可以在子进程中使用，这叫做环境变量（environment variable）；

#### 2.3.2 局部变量

在 Shell 函数中定义的变量默认也是全局变量，它和在函数外部定义变量拥有一样的效果，要想变量的作用域仅限于函数内部，可以在定义时加上`local`命令，此时该变量就成了局部变量。

#### 2.3.3 全局变量

所谓全局变量，就是指变量在当前的整个 Shell 进程中都有效。每个 Shell 进程都有自己的作用域，彼此之间互不影响。在 Shell 中定义的变量，默认就是全局变量。

#### 2.3.4 环境变量

全局变量只在当前 Shell 进程中有效，对其它 Shell 进程和子进程都无效。如果使用export命令将全局变量导出，那么它就在所有的子进程中也有效了，这称为“环境变量”。

通过 export 导出的环境变量只对当前 Shell 进程以及所有的子进程有效，如果最顶层的父进程被关闭了，那么环境变量也就随之消失了，其它的进程也就无法使用了，所以说环境变量也是临时的。

### 2.4 位置参数(看到了特殊变量一节)

http://c.biancheng.net/view/706.html

运行 Shell 脚本文件时我们可以给它传递一些参数，这些参数在脚本文件内部可以使用$n的形式来接收，例如，$1 表示第一个参数，$2 表示第二个参数，依次类推。

同样，在调用函数时也可以传递参数。Shell 函数参数的传递和其它编程语言不同，没有所谓的形参和实参，在定义函数时也不用指明参数的名字和数目。换句话说，定义 Shell 函数时不能带参数，但是在调用函数时却可以传递参数，这些传递进来的参数，在函数内部就也使用$n的形式接收，例如，$1 表示第一个参数，$2 表示第二个参数，依次类推。

这种通过$n的形式来接收的参数，在 Shell 中称为位置参数。

在讲解变量的命名时，我们提到：变量的名字必须以字母或者下划线开头，不能以数字开头；但是位置参数却偏偏是数字，这和变量的命名规则是相悖的，所以我们将它们视为“特殊变量”。

1) 给脚本文件传递位置参数

2) 给函数传递位置参数

```shell
#!/bin/bash

#定义函数
function func(){
    echo "Language: $1"
    echo "URL: $2"
}

#调用函数
func C++ http://c.biancheng.net/cplus/
```



## 3 shell基本的语法结构

### 3.2 数组

#### 3.2.1 数组的定义

- 数组（Array）是若干数据的集合，其中的每一份数据都称为元素（Element）
- bash支持一维数组（不支持多维数组），并且没有限定数组的大小，数组元素的下标由0开始编号，在Shell中，用括号来表示数组，数组元素用“空格”符号分割开；
- Shell 是弱类型的，它并不要求所有数组元素的类型必须相同；
- Shell 数组的长度不是固定的，定义之后还可以增加元素；

```shell
    # 定义一个包含数字的数组
    array_num=(1 2 3 4 5)
    # 向数组添加元素或者替换现有元素的值
    array_num[6]=6  # array_num[0]=10
    # 定义数组时可以通过单一指定元素的方式构建一个数组
    ahcui[0]=10
    achui[1]=20
    echo ${achui[@]}  # 输出全部的数组元素
    echo ${achui[3]}  # 因为下标3指定的元素未定义，所以输出为空
```

#### 3.2.2 数组的读取和删除

读取数组元素值的一般格式是：

```shell
    ${array_name[index]}
```

使用@ 或 * 可以获取数组中的所有元素

```shell
    ${array_name[@]}  # 或者使用 ${array_name[*]} 
```

在 Shell 中，使用 unset 关键字来删除数组元素，如果直接使用数组名则会删除整个数组，所有元素都会消失。

```shell
names=("achui" "bigachui")
unset names[0]  # 删除特定的数组元素
unset names  # 删除整个数组
```

#### 3.2.4 数据的长度获取

获取数组长度的方法与获取字符串长度的方法相同

```shell
# 取得数组元素的个数
length=${#array_name[@]}
# 或者
length=${#array_name[*]}
# 取得数组单个元素的长度
lengthn=${#array_name[n]}
```
































## 函数

### 函数的基本定义

```shell
# 函数的基本结构如下所示
# 1）关键字function可省略，建议不省略
# 2）函数名后如不传参中括号可省略（省略时function需要保留），建议不省略
# 3）函数体后的返回值为0～255的整数，可省略
[ function ] funname [()]

{

    statement

    [return int]

}
```

注意：所有函数在使用前必须定义。这意味着必须将函数放在脚本开始部分，直至shell解释器首次发现它时，才可以使用。调用函数仅使用其函数名即可。


### 函数的调用和传参

函数调用直接通过函数名可以完成调用，不需要使用调用运算符`()`

```shell
function sayHello() {
	echo "hello world!"
}

sayHello
```

如果需要给函数传参可以使用如下形式

```shell
# functionName param1 param2 param3

function sayHello() {
	echo "hello ${1} ,your age is ${2}"
}

sayHello achui 18
```

函数参数是 Shell 位置参数的一种，在函数内部可以使用$n来接收，例如，$1 表示第一个参数，$2 表示第二个参数，依次类推, 注意，参数n > 10时，需要使用{}划定边界，如${10}













### shell传参

将文本字符串作为参数传递时,引号并非数据的一部分。它们只是表明数据的起止位置



每个参数都是用空格分隔的,所以shell会将空格当成两个值的分隔符。要在参数值中
包含空格,必须要用引号(单引号或双引号均可)。



如果脚本需要的命令行参数不止9个,你仍然可以处理,但是需要稍微修改一下变量名。在
第9个变量之后,你必须在变量数字周围加上花括号,比如 ${10}



bash shell会将一些称为位置参数(positional parameter)的特殊变量分配给输入到命令行中的
所有参数。



当传给 $0 变量的实际字符串不仅仅是脚本名,而是完整的脚本路径时,
变量 $0 就会使用整个路径。



如果你要编写一个根据脚本名来执行不同功能的脚本,就得做点额外工作。你得把脚本的运
行路径给剥离掉。另外,还要删除与脚本名混杂在一起的命令。
幸好有个方便的小命令可以帮到我们。 basename 命令会返回不包含路径的脚本名。

name=$(basename $0)