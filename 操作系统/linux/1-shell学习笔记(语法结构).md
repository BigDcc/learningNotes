# shell基础入门

[TOC]

## 1 shell的基本介绍

### 1.1 shell概述

#### 1.1.1 shell简介

- `Unix`刚开始只支持一种交互式`shell`,它是由`Stephen Bourne`所编写的`Bourne Shell(sh)`;
- 1989年,`GNU`项目的Brian Fox吸收了大量其他用户界面的特性,编写出了一种全新的shell:
`Bourne Again Shell(bash)`，`bash shell`与`Bourne Shell`完全兼容;
- 随着Linux成为最流行的类Unix操作系统实现,`bash shell`也变成了`Unix`和`Linux`中既成事实的标准`shell`;
- Shell 是一个应用程序，它连接了用户和 Linux 内核，让用户能够更加高效、安全、低成本地使用 Linux 内核，这就是 Shell 的本质。

![shell](./res/001.png)

#### 1.1.2 查看和更换当前使用的shell

```shell
# 当前 Linux 系统可用的 Shell 都记录在/etc/shells文件中
cat /etc/shells

# 查看当前正在使用的shell
echo $SHELL

# 更换使用的shell，如下更换zsh为默认bash，这个更换也没啥用，对于一般的工具人来说，会用bash就可以了，针对一些高级人士而言可能有点用，注意更换的时候要注意/etc/shells下支持的才可以更换
chsh -s /bin/zsh
```

#### 1.1.3 用户的默认shell

- 系统启动什么样的shell程序取决于你个人的用户ID配置。在/etc/passwd文件中，在用户ID记录的第7个字段中列出了默认的shell程序。只要用户登录到某个虚拟控制台终端或是在GUI中启动终端仿真器，默认的shell程序就会开始运行。

- 还有另外一个默认shell是/bin/sh，它作为默认的系统shell，用于那些需要在启动时使用的系统shell脚本。你经常会看到某些发行版使用软链接将默认的系统shell设置成bash shell(如centos)

### 1.2 bash shell概述

#### 1.2.1 bash简介

1. bash shell 是 Linux 的默认 shell，免费易用，功能强大。

   ```shell
   # Shell 通过PS1和PS2两个环境变量来控制提示符格式；
   # Base shell 默认的提示符是美元符号$；对于超级用户（root 用户），Bash Shell 默认的提示符是井号#
   # PS1 控制最外层命令行的提示符格式；
   # PS2 控制第二层命令行的提示符格式, 所谓的第二层就是你在输入for这些结构时需要换行时，前面的提示符；
   # 这个一般不用更改，如果有兴趣定制自己的提示符，可以搜索下具体的构建规则。
   ```

4. 通常我们说的shell和shell script是两种东西，前者指的是一个软件，解释器，后者指的是根据一定的语法规则生成的文本，通常以sh结尾，通过shell去调用shell script， bash中支持程序脚本化;

#### 1.2.2 bash shell的特点

- 历史命令（history）
  - 通常历史命令记录在~/.bash_history文件中，该文件记录的是前一次登录以前所执行过的命令，不包含本次执行的命令， 记录的具体数量由HISTFILESIZE变量控制；
- 命令与文件补全功能（Tab）
- 命令别名设置功能（alias）
- 任务管理，前后台控制（job control, foreground, background）
- 程序化脚本（shell scripts）
- 通配符

#### 1.2.3 内部与外部命令

​		在 Shell 中输入的命令，有一部分是 Shell 本身自带的，这叫做**内置命令**，有一部分是其它的应用程序（一个程序就是一个命令），这叫做**外部命令**。

​		通常可以使用`type`命令来区分一个命令是内部命令还是外部命令;

```shell
type dos2unix
# dos2unix 是 /usr/bin/dos2unix

type cd
# cd 是 shell 内建
```

> **深度解析内部和外部命令：**

> - Shell 自带的命令称为内置命令，它在 Shell 内部可以通过函数来实现，当 Shell 启动后，这些命令所对应的代码（函数体代码）也被加载到内存中，所以使用内置命令是非常快速的。
> - 更多的命令是外部的应用程序，一个命令就对应一个应用程序。运行外部命令要开启一个新的进程，所以效率上比内置命令差很多。

#### 1.2.4 别名

​		在代码中使用 alias 命令定义的别名只能在当前 Shell 进程中使用，在子进程和其它进程中都不能使用。当前 Shell 进程结束后，别名也随之消失。

​		使用 unalias 内建命令可以删除当前 Shell 进程中的别名。unalias 有两种使用方法：

- 第一种用法是在命令后跟上某个命令的别名，用于删除指定的别名。
- 第二种用法是在命令后接`-a`参数，删除当前 Shell 进程中所有的别名。

```shell
alias rm='rm -i'  # 删除时进行提示

# alias只是临时的，所以如果想要进行'持久化'，可以将其写在.bashrc中
```

#### 1.2.5 运行shell的四种方式

​		Shell 一共有四种运行方式：

- 交互式的登录 Shell；
- 交互式的非登录 Shell；
- 非交互式的登录 Shell；
- 非交互式的非登录 Shell；

> **交互，非交互，登录，非登录的概念介绍**

> - 我们可以直接使用 Shell，也可以输入用户名和密码后再使用 Shell；第一种叫做非登录式，第二种叫做登录式。
>
> - 我们可以直接使用 Shell，也可以输入用户名和密码后再使用 Shell；第一种叫做非登录式，第二种叫做登录式。

> **判断是否为交互式**

> ```shell
> echo $-  # 包含字母i证明为交互式
> himBHs
> 
> # ---------------------------------------------
> cat test.sh  # 输出结果中不包含i为非交互式
> #! /bin/bash
> echo $-
> 
> bash ./test.sh
> 
> hb
> ```

> **判断是否为登录式**

> ​		判断 Shell 是否为登录式也非常简单，只需执行`shopt login_shell`即可，值为`on`表示为登录式，`off`为非登录式。
>
> - ***当我们通过图形化的方式登录到一个linux系统上时，在图形化界面中打开一个虚拟终端，其实此时打开的就是一个非登录式的终端，而我们此前输入的用户名，密码是验证是否可登入系统的凭证***
> - ***通过 Linux 控制台（不是桌面环境自带的终端）或者 ssh 登录 Shell 时（这才是正常登录方式），为交互式的登录 Shell。***
> - ***执行 bash 命令时默认是非登录的，增加`--login`选项（简写为`-l`）后变成登录式(当父进程是登录式时，子进程会继承登录状态)***
> - ***使用由`()`包围的组命令或者命令替换进入子 Shell 时，子 Shell 会继承父 Shell 的交互和登录属性。***
> -  ***ssh 执行远程命令，但不登录时，为非交互非登录式***

#### 1.2.6 配置文件加载

​		无论是否是交互式，是否是登录式，Bash Shell 在启动时总要配置其运行环境，不同的启动方式，加载的配置文件是不同的，这在编写服务脚本时，很重要！

- 如果是登录式的 Shell，首先会读取和执行 /etc/profiles，这是所有用户的全局配置文件，接着会到用户主目录中寻找 ~/.bash_profile、~/.bash_login 或者 ~/.profile，它们都是用户个人的配置文件。不同的 Linux 发行版附带的个人配置文件也不同，有的可能只有其中一个，有的可能三者都有，如果三个文件同时存在的话，到底应该加载哪一个呢？它们的优先级顺序是 ~/.bash_profile > ~/.bash_login > ~/.profile；

- 如果以非登录的方式启动 Shell，那么就不会读取以上所说的配置文件，而是直接读取 ~/.bashrc；

> **注意事项**

> 登录方式中加载的注意事项：
>
> - /etc/profiles 文件还会嵌套加载 /etc/profile.d/*.sh
> - ~/.bash_profile 嵌套加载 ~/.bashrc
>
> 非登录方式加载的注意事项：
>
> - ~/.bashrc 文件还会嵌套加载 /etc/bashrc

​		**对于普通用户来说，也许 ~/.bashrc 才是最重要的文件，因为不管是否登录都会加载该文件。**

#### 1.2.7 命令查找顺序

​		在Linux上执行一个可执行程序，或者命令时，shell的查找顺序如下，如果依旧以下顺序未查找到该命令，则报`command not found`:

1. 以相对/绝对路径执行命令；
2. 由alias找到该命令来执行;
3. 由bash内置的命令来执行；
4. 通过$PATH变量记录的路径顺序进行一一查找；

### 1.3 shell脚本的基本事项

#### 1.3.1 注释和解释器声明

1. **单行注释**

   bash将以 `#` 符号开头的行视为注释， 所以我们在写shell脚本的时候，`#`代表注释

2. **多行注释** - 以 `:<<EOF` 开头，到 `EOF` 结束

   ```shell
   test.txt<<EOF
   
   abcdef
   
   hello word !
   
   FFFFFFFFFFFFFFFFFFFFFFF
   
   EOF
   ```

3. **shebang**

   shell脚本通常以shebang起始，来声明解释器
   
   ```shell
   #!/bin/bash
   ```

> **注意事项**

> - shebang是一个文本行,其中 `#!` 位于解释器路径之前。 
>- /bin/bash是Bash的解释器命令路径。
> - 脚本中只有第一行可以使用shebang来定义解释该脚本所使用的解释器

#### 1.3.2 shell脚本执行的两种方式

​		**如果开始写shell脚本？**		

新建一个文件，扩展名为sh（sh代表shell），扩展名并不影响脚本执行，见名知意就好，文件的尾缀对于windows来说可能有用，但是对于linux来说没啥用，在你使用vim这些编辑器的时候，会根据尾缀提供语法高亮等功能。

​		**执行shell脚本的方式**

1. 需要给权限的执行方式

```shell
# 在当前路径下执行一个shell脚本，注意三点，
# 1. 脚本需要有可执行权限
# 2. 前面的路径一定要给，./代表当前，否则会搜索PATH中记录的路径，可能造成command not found错误
# 3. 在脚本中一定要声明shebang，用来声明所使用的解释器
./test.sh
```

 	2. 将脚本作为参数传递给解释器

```shell
# 将脚本作为参数传给解释器，只需要注意一点，就是路径问题，如果在当前路径下执行，文件是可以省略前面的路径的
# 这种执行方式的shebang可有可无，因为不会被调用
bash test.sh
```

#### 1.3.3 换行与同行

- shell中一条命令占据一行，脚本从上到下顺序执行；

- 使用分号`；`可以将多条命令合并在一行中；

- 使用`\`换行；

> **注意事项**

> - 同行多条语句这种情况，一般不符合编写规则，不建议在脚本中出现这种写法
> - 在一行中尽量不要超过80个字符，最多不能超过120个，如果超过了，尽量在低优先级运算符处进行换行操作

### 1.4 输入输出命令

#### 1.4.1 echo

- echo 是用于终端打印的最基本命令，默认情况下, echo 在每次调用后会添加一个换行符;
- echo 会在输出文本的尾部追加一个换行符。可以使用选项 -n 来禁止这种行为;
- echo后面的文本信息支持直接打印或者使用引号包含打印，三种形式有不一样的效果

```shell
echo hello word！
双引号允许shell解释字符串中出现的特殊字符
单引号不会对其做任何解释
如果不使用引号,我们无法在 echo 中使用分号,因为分号在Bash shell中用作命令间的分隔符
```
echo

包含转义序列的字符串 " 这种形式。例如:
echo -e "1\t2\t3"



要打印彩色文本,可输入如下命令:
echo -e "\e[1;31m This is red text \e[0m"
其中 \e[1;31m 是一个转义字符串,可以将颜色设为红色, \e[0m 将颜色重新置回



其中包括:重置=0,黑色=30,红色=31,绿色=32,
黄色=33,蓝色=34,洋红=35,青色=36,白色=37



对于彩色背景,经常使用的颜色码是:重置=0,黑色=40,红色=41,绿色=42,黄色=43,
蓝色=44,洋红=45,青色=46,白色=47。

#### 1.4.2 printf

​		printf 命令接受引用文本或由空格分隔的参数,默认情况下, printf 并不会自动添加换行符

#### 1.4.3 read

​		用于读取来自键盘输入的变量，语法格式如下所示：

```shell
read [option] variable
# 常用的option
# -t 等待秒数,不会一直等待用户输入
# -p 提示信息

read -p "please input your name!" name
echo ${name}
```



### 1.5 exit

​		exit 是一个Shell 内置命令，用来退出当前 Shell 进程，并返回一个退出状态；使用`$?`可以接收这个退出状态

​		exit 命令可以接受一个整数值作为参数，代表退出状态。如果不指定，默认状态值是 0

​		exit 退出状态只能是一个介于 0~255 之间的整数，其中只有 0 表示成功，其它值都表示失败

### 1.6  declare和typeset

​		declare 和 typeset 都是 Shell 内建命令，它们的用法相同，都是用来生命变量的类型，不过 typeset 已经被弃用了，建议使用 declare 代替，语法格式如下所示，包含了常用的选项：

```shell
declare [-aixr] variable

-a : 声明变量为数组类型
-i : 声明变量为整数类型
-x : 将变量升级为环境变量，功能与export相同
-r : 将变量设置为只读类型变量，不能修改，也不可unset
```

​		***在变量声明的时候，可以进行赋值操作***

date

### 1.7 shell脚本模块化

​		所谓模块化，就是把代码分散到多个文件或者文件夹。通过导包的方式加载其他的模块，如python中的import语句，在shell中我们通过内置命令source命令进行模块的加载。

​		source 命令的用法为：

```shell
source filename  # source 命令会强制执行脚本文件中的全部命令，而忽略脚本文件的权限。
```

​		也可以简写为：

```shell
. filename
```

>  **注意事项:**

> **避免重复导入问题：**
>
> Shell source 命令和 C/C++ 中的 #include 类似，都没有避免重复引入的功能，只要你使用一次 source，它就引入一次脚本文件中的代码。
>
> - 可以在模块中额外设置一个变量，使用 if 语句来检测这个变量是否存在，如果发现这个变量存在，就 return 出去。
> - 在 Shell 中，return 除了可以退出函数，还能退出由 source 命令引入的脚本文件。

### 1.8 bash中的快捷操作

| 按键   | 作用                                                   |
| ------ | ------------------------------------------------------ |
| Ctrl+a | 移动光标到行首。                                       |
| Ctrl+e | 移动光标到行尾。                                       |
| Ctrl+f | 光标前移一个字符；和右箭头作用一样。                   |
| Ctrl+b | 光标后移一个字符；和左箭头作用一样。                   |
| Alt+f  | 光标前移一个字。                                       |
| Alt+b  | 光标后移一个字。                                       |
| Ctrl+l | 清空屏幕，移动光标到左上角。clear 命令完成同样的工作。 |

| 按键   | 作用                                     |
| ------ | ---------------------------------------- |
| Ctrl+d | 删除光标位置的字符。                     |
| Ctrl+t | 光标位置的字符和光标前面的字符互换位置。 |
| Alt+t  | 光标位置的字和其前面的字互换位置。       |
| Alt+l  | 把从光标位置到字尾的字符转换成小写字母。 |
| Alt+u  | 把从光标位置到字尾的字符转换成大写字母。 |

| 按键          | 作用                                                         |
| ------------- | ------------------------------------------------------------ |
| Ctrl+k        | 剪切从光标位置到行尾的文本。                                 |
| Ctrl+u        | 剪切从光标位置到行首的文本。                                 |
| Alt+d         | 剪切从光标位置到词尾的文本。                                 |
| Alt+Backspace | 剪切从光标位置到词头的文本。如果光标在一个单词的开头，剪切前一个单词。 |
| Ctrl+y        | 把剪切环中的文本粘贴到光标位置。                             |

## 2 变量

### 2.1 定义变量

#### 2.1.1 变量的一些注意事项

- 在定义变量时不需要指明类型，直接赋值就可以；
- 在 Bash shell 中，每一个变量的值都是字符串，无论你给变量赋值时有没有使用引号，值都会以字符串的形式存储；
- Bash shell 在默认情况下不会区分变量类型，即使你将整数和小数赋值给变量，它们也会被视为字符串；
- 可以使用 declare 关键字显式定义变量的类型，但在一般情况下没有这个需求；
- 赋值号=的周围不能有空格，因为shell中的空格加等号的形式已经被判断所占用；

#### 2.1.2 定义变量

##### 2.1.2.1 变量名的规范

​		Shell 变量的命名规范和大部分编程语言都一样：

- 变量名由数字、字母、下划线组成；
- 必须以字母或者下划线开头；
- 不能使用 Shell 里的关键字（通过 help 命令可以查看保留关键字）;
- 常用的惯例是在脚本中使用大写字母命名环境变量,使用驼峰命名法或小写字母命名其他变量（不过推荐Unix风格命令变量，即使用下划线命名法）。

> **注意事项：**

> 在bash当中，当一个变量尚未被设置时，默认的内容是【空】

##### 2.1.2.2 定于变量的语法结构

​		Shell 支持以下三种定义变量的方式：

```shell
variable=value
variable='value'
variable="value"
```

- variable 是变量名，value 是赋给变量的值。如果 value 不包含任何空白符（例如空格、Tab 缩进等），那么可以不使用引号；
- 如果 value 包含了空白符，那么就必须使用引号包围起来。使用单引号和使用双引号也是有区别的，以单引号`' '`包围变量的值时，单引号里面是什么就输出什么，即使内容中有变量和命令（命令需要反引起来）也会把它们原样输出。这种方式比较适合定义显示纯字符串的情况，即不希望解析变量、命令等的场景。以双引号`" "`包围变量的值时，输出时会先解析里面的变量和命令，而不是把双引号中的变量名和命令原样输出。这种方式比较适合字符串中附带有变量和命令并且想将其解析后再输出的变量定义；

- shell命名时使用的`=`两边不能有空格，这跟常见的其他语言是不同的，因为等号两边包含空格的形式已经被条件测试的语言格式所占用（等量关系测试）；

### 2.2 使用变量

#### 2.2.1 引用变量

​		使用一个定义过的变量，只要在变量名前面加美元符号$即可，有时候变量出现在一些字符串中时，可以在引用变量时加花括号帮助解释器识别变量的边界（推荐给所有变量加上花括号{ }）

```shell
name="achui"
echo "your name is ${name}"
```

#### 2.2.2 修改变量的值

​		已定义的变量，可以被重新赋值，第二次对变量赋值时不能在变量名前加`$`，只有在使用变量时才能加`$`

```shell
name="achui"
echo "your name is ${name} " # your name is achui
name="bigachui"
echo "your name is ${name} "  # your name is bigachui
```

#### 2.2.3 只读变量

​		使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变，要想修改当前的只读变量，只能停止当前的进程了。

```shell
readonly version="10.1.1"
version="0.1" # 只读变量禁止修改，执行时会报错`bash: version: 只读变量`
```

#### 2.2.4 将命令的结果赋值给变量

​		Shell 支持将命令的执行结果赋值给变量，常见的有以下两种方式：

```shell
variable=`command`   # 这种方式可读性太差
variable=$(command)  # 推荐使用这种方式
```

​		要注意的是，$() 仅在 Bash Shell 中有效，而反引号可在多种 Shell 中使用。

#### 2.2.5 删除变量

​		使用 unset 命令可以删除变量，变量被删除后不能再次使用；unset 命令不能删除只读变量。

```shell
name="achui"
unset name
echo ${name}  # 输出为空，因为变量被删除了
```

### 2.3 变量的作用域

#### 2.3.1 作用域的分类

​		Shell 变量的作用域可以分为三种：

- 有的变量只能在函数内部使用，这叫做局部变量（local variable）；
- 有的变量可以在当前 Shell 进程中使用，这叫做全局变量（global variable）；
- 而有的变量还可以在子进程中使用，这叫做环境变量（environment variable）；

#### 2.3.2 局部变量

​		在 Shell 函数中定义的变量默认也是全局变量，它和在函数外部定义变量拥有一样的效果，要想变量的作用域仅限于函数内部，可以在定义时加上`local`命令，此时该变量就成了局部变量。

```shell
function hello() {
	hello="hello"
	local hi="hi"
}

hello
echo ${hello} # hello
echo ${hi} # 结果为空
```

#### 2.3.3 全局变量

​		所谓全局变量，就是指变量在当前的整个 Shell 进程中都有效。每个 Shell 进程都有自己的作用域，彼此之间互不影响。在 Shell 中定义的变量，默认就是全局变量。

#### 2.3.4 环境变量

​		全局变量只在当前 Shell 进程中有效，对其它 Shell 进程和子进程都无效。如果使用export命令将全局变量导出，那么它就在所有的子进程中也有效了，这称为“环境变量”。

​		通过 export 导出的环境变量只对当前 Shell 进程以及所有的子进程有效，如果最顶层的父进程被关闭了，那么环境变量也就随之消失了，其它的进程也就无法使用了，所以说环境变量也是临时的。

>  **查看环境变量**

> - 可以使用 `env` 或 `printenv` 命令查看当前shell中所定义的全部环境变量;
> - 使用`set`命令可以查看当前所有的变量，包含环境变量与自定义变量；
> - 要查看其他进程的环境变量cat /proc/$PID/environ；
> - 可以使用 `pgrep` 命令获得名为gedit的进程ID, `pgrep gedit`；

### 2.4 位置参数

#### 2.4.1 位置参数

​		运行 Shell 脚本文件时我们可以给它传递一些参数，这些参数在脚本文件内部可以使用$n的形式来接收，例如，$1 表示第一个参数，$2 表示第二个参数，依次类推。

​		同样，在调用函数时也可以传递参数。Shell 函数参数的传递和其它编程语言不同，没有所谓的形参和实参，在定义函数时也不用指明参数的名字和数目。换句话说，定义 Shell 函数时不能带参数，但是在调用函数时却可以传递参数，这些传递进来的参数，在函数内部就也使用$n的形式接收，例如，$1 表示第一个参数，$2 表示第二个参数，依次类推。如果参数个数太多，达到或者超过了 10 个，那么就得用`${n}`的形式来接收了。

​		这种通过$n的形式来接收的参数，在 Shell 中称为**位置参数**。

​		在讲解变量的命名时，我们提到：变量的名字必须以字母或者下划线开头，不能以数字开头；但是位置参数却偏偏是数字，这和变量的命名规则是相悖的，所以我们将它们视为“**特殊变量**”。

1. 给脚本文件传递位置参数

```shell
# 定义一个test脚本test.sh
echo "hello "$1

# 传参
test.sh hello
```

2. 给函数传递位置参数

```shell
#!/bin/bash

#定义函数
function sayhello() {
   echo "hello "$1
}

#调用函数
sayhello "achui"
```

​	***这里值得注意的是$0代表的是函数名或者文件名。***

#### 2.4.2 特殊变量

| 变量      | 含义                                                         |
| --------- | ------------------------------------------------------------ |
| $0        | 当前脚本的文件名。                                           |
| $n（n≥1） | 传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是 $1，第二个参数是 $2。 |
| $#        | 传递给脚本或函数的参数个数。                                 |
| $*        | 传递给脚本或函数的所有参数。                                 |
| $@        | 传递给脚本或函数的所有参数。                                 |
| $?        | 上个命令的退出状态，或函数的返回值。                         |
| $$        | 当前 Shell 进程 ID。对于 Shell 脚本，就是这些脚本所在的进程 ID。 |

> **注意事项：**

> **$* 和 $@ 的区别**	
>
> ​		当 $* 和 $@ 不被双引号`" "`包围时，它们之间没有任何区别，都是将接收到的每个参数看做一份数据，彼此之间以空格来分隔。
>
> 但是当它们被双引号`" "`包含时，就会有区别了：
>
> - `"$*"`会将所有的参数从整体上看做一份数据，而不是把每个参数都看做一份数据。
> - `"$@"`仍然将每个参数都看作一份数据，彼此之间是独立的。

### 2.5 变量替换

| 变量配置方式     | str 没有配置       | str 为空字符串     | str 已配置非为空字符串 |
| ---------------- | ------------------ | ------------------ | ---------------------- |
| var=${str-expr}  | var=expr           | var=               | var=$str               |
| var=${str:-expr} | var=expr           | var=expr           | var=$str               |
| var=${str+expr}  | var=               | var=expr           | var=expr               |
| var=${str:+expr} | var=               | var=               | var=expr               |
| var=${str=expr}  | str=expr var=expr  | str 不变 var=      | str 不变 var=$str      |
| var=${str:=expr} | str=expr var=expr  | str=expr var=expr  | str 不变 var=$str      |
| var=${str?expr}  | expr 输出至 stderr | var=               | var=$str               |
| var=${str:?expr} | expr 输出至 stderr | expr 输出至 stderr | var=$str               |



## 3 shell数据类型与语法结构

### 3.1 字符串

#### 3.1.1 字符串的基本格式

​		字符串（String）就是一系列字符的组合。字符串可以由单引号`' '`包围，也可以由双引号`" "`包围，也可以不用引号。

1. 由单引号`' '`包围的字符串：

	- 任何字符都会原样输出，在其中使用变量是无效的。
	- 字符串中不能出现单引号，即使对单引号进行转义也不行。

2. 由双引号`" "`包围的字符串：

	- 如果其中包含了某个变量，那么该变量会被解析（得到该变量的值），而不是原样输出。
	- 字符串中可以出现双引号，只要它被转义了就行。

3. 不被引号包围的字符串

	- 不被引号包围的字符串中出现变量时也会被解析，这一点和双引号`" "`包围的字符串一样。
	- 字符串中不能出现空格，否则空格后边的字符串会作为其他变量或者命令解析。

#### 3.1.2 字符串的长度获取与拼接操作

1. 长度获取

```shell
${#string_name}
```

2. 在 Shell 中你不需要使用任何运算符，将两个字符串并排放在一起就能实现拼接

```shell
name="achui"
age="18"
echo "'info '${name}' is '${age}"
```

#### 3.1.3 字符串的截取

​		Shell 截取字符串通常有两种方式：

- 从指定位置开始截取
- 从指定字符（子字符串）开始截取

| 格式                       | 说明                                                         |
| -------------------------- | ------------------------------------------------------------ |
| ${string: start :length}   | 从 string 字符串的左边第 start 个字符开始，向右截取 length 个字符。 |
| ${string: start}           | 从 string 字符串的左边第 start 个字符开始截取，直到最后。    |
| ${string: 0-start :length} | 从 string 字符串的右边第 start 个字符开始，向右截取 length 个字符。 |
| ${string: 0-start}         | 从 string 字符串的右边第 start 个字符开始截取，直到最后。    |
| ${string#*chars}           | 从 string 字符串第一次出现 *chars 的位置开始，截取 *chars 右边的所有字符。 |
| ${string##*chars}          | 从 string 字符串最后一次出现 *chars 的位置开始，截取 *chars 右边的所有字符。 |
| ${string%*chars}           | 从 string 字符串第一次出现 *chars 的位置开始，截取 *chars 左边的所有字符。 |
| ${string%%*chars}          | 从 string 字符串最后一次出现 *chars 的位置开始，截取 *chars 左边的所有字符。 |

#### 从字符串左边开始计数

### 3.2 数组

#### 3.2.1 数组的定义

- 数组（Array）是若干数据的集合，其中的每一份数据都称为元素（Element）
- bash支持一维数组（不支持多维数组），并且没有限定数组的大小，数组元素的下标由0开始编号，在Shell中，用括号来表示数组，数组元素用“空格”符号分割开；
- Shell 是弱类型的，它并不要求所有数组元素的类型必须相同；
- Shell 数组的长度不是固定的，定义之后还可以增加元素；

```shell
    # 定义一个包含数字的数组
    array_num=(1 2 3 4 5)
    # 向数组添加元素或者替换现有元素的值
    array_num[6]=6  # array_num[0]=10
    # 定义数组时可以通过单一指定元素的方式构建一个数组
    ahcui[0]=10
    achui[1]=20
    echo ${achui[@]}  # 输出全部的数组元素
    echo ${achui[3]}  # 因为下标3指定的元素未定义，所以输出为空
```

#### 3.2.2 数组的读取和删除

​		读取数组元素值的一般格式是：

```shell
    ${array_name[index]}
```

​		使用@ 或 * 可以获取数组中的所有元素

```shell
    ${array_name[@]}  # 或者使用 ${array_name[*]} 
```

​		在 Shell 中，使用 unset 关键字来删除数组元素，如果直接使用数组名则会删除整个数组，所有元素都会消失。

```shell
names=("achui" "bigachui")
unset names[0]  # 删除特定的数组元素
unset names  # 删除整个数组
```

#### 3.2.3 数组拼接

​		拼接数组的思路是：先利用`@`或`*`，将数组扩展成列表，然后再合并到一起。具体格式如下：

```shell
array_new=(${array1[@]}  ${array2[@]})
array_new=(${array1[*]}  ${array2[*]})
```

#### 3.2.4 数据的长度获取

​		获取数组长度的方法与获取字符串长度的方法相同

```shell
# 取得数组元素的个数
length=${#array_name[@]}
# 或者
length=${#array_name[*]}
# 取得数组单个元素的长度
lengthn=${#array_name[n]}
```

#### 3.2.5 数组元素删除

​		在 Shell 中，使用 unset 关键字来删除数组元素，具体格式如下：

```shell
unset array_name[index]
```

#### 3.2.6 关联数组

### 3.3 运算符

| 算术运算符            | 说明/含义                                                |
| --------------------- | -------------------------------------------------------- |
| +、-                  | 加法（或正号）、减法（或负号）                           |
| *、/、%               | 乘法、除法、取余（取模）                                 |
| **                    | 幂运算                                                   |
| ++、--                | 自增和自减，可以放在变量的前面也可以放在变量的后面       |
| !、&&、\|\|           | 逻辑非（取反）、逻辑与（and）、逻辑或（or）              |
| <、<=、>、>=          | 比较符号（小于、小于等于、大于、大于等于）               |
| ==、!=、=             | 比较符号（相等、不相等；对于字符串，= 也可以表示相当于） |
| <<、>>                | 向左移位、向右移位                                       |
| ~、\|、 &、^          | 按位取反、按位或、按位与、按位异或                       |
| =、+=、-=、*=、/=、%= | 赋值运算符，例如 a+=1 相当于 a=a+1，a-=1 相当于 a=a-1    |

| 逻辑运算符 | 使用格式                     | 说明                                                         |
| ---------- | ---------------------------- | ------------------------------------------------------------ |
| &&         | expression1 && expression2   | 逻辑与运算符，当 expression1 和 expression2 同时成立时，整个表达式才成立。  如果检测到 expression1 的退出状态为 0，就不会再检测 expression2 了，因为不管 expression2 的退出状态是什么，整个表达式必然都是不成立的，检测了也是多此一举。 |
| \|\|       | expression1 \|\| expression2 | 逻辑或运算符，expression1 和 expression2 两个表达式中只要有一个成立，整个表达式就成立。  如果检测到 expression1 的退出状态为 1，就不会再检测 expression2 了，因为不管 expression2 的退出状态是什么，整个表达式必然都是成立的，检测了也是多此一举。 |
| !          | !expression                  | 逻辑非运算符，相当于“取反”的效果。如果 expression 成立，那么整个表达式就不成立；如果 expression 不成立，那么整个表达式就成立。 |

### 3.4 数学计算



Bash shell使用 let 、 (( )) 和 [] 执行基本的算术操作。工具 expr 和 bc 可以用来执行高级操作

let 命令可以直接执行基本的算术操作。当使用 let 时,变量名之前不需要再添加 $

let result=no1+no2
echo $result

$ let no1++

$ let no1--

操作符 [] 的使用方法和 let 命令一样:
result=$[ no1 + no2 ]
7
在 [] 中也可以使用 $ 前缀,例如:
result=$[ $no1 + 5 ]
8
也可以使用操作符 (()) 。出现在 (()) 中的变量名之前需要加上 $ :
result=$(( no1 + 50 ))

### 3.5 test与[[]]

#### 3.5.1 test

​		test 是 Shell 内置命令，用来检测某个条件是否成立。test 通常和 if 语句一起使用，并且大部分 if 语句都依赖 test。

​		Shell test 命令的用法为：

```shell
# 当 test 判断 expression 成立时，退出状态为 0，否则为非 0 值
# test 命令也可以简写为[]，它的用法为：[ expression ]
test expression
```

​		常使用的test选项：

| 文件类型判断            |                                                              |
| ----------------------- | ------------------------------------------------------------ |
| 选 项                   | 作 用                                                        |
| -b filename             | 判断文件是否存在，并且是否为块设备文件。                     |
| -c filename             | 判断文件是否存在，并且是否为字符设备文件。                   |
| -d filename             | 判断文件是否存在，并且是否为目录文件。                       |
| -e filename             | 判断文件是否存在。                                           |
| -f filename             | 判断文件是否存在，井且是否为普通文件。                       |
| -L filename             | 判断文件是否存在，并且是否为符号链接文件。                   |
| -p filename             | 判断文件是否存在，并且是否为管道文件。                       |
| -s filename             | 判断文件是否存在，并且是否为非空。                           |
| -S filename             | 判断该文件是否存在，并且是否为套接字文件。                   |
| 文件权限判断            |                                                              |
| 选 项                   | 作 用                                                        |
| -r filename             | 判断文件是否存在，并且是否拥有读权限。                       |
| -w filename             | 判断文件是否存在，并且是否拥有写权限。                       |
| -x filename             | 判断文件是否存在，并且是否拥有执行权限。                     |
| -u filename             | 判断文件是否存在，并且是否拥有 SUID 权限。                   |
| -g filename             | 判断文件是否存在，并且是否拥有 SGID 权限。                   |
| -k filename             | 判断该文件是否存在，并且是否拥有 SBIT 权限。                 |
| 文件比较                |                                                              |
| 选 项                   | 作 用                                                        |
| filename1 -nt filename2 | 判断 filename1 的修改时间是否比 filename2 的新。             |
| filename -ot filename2  | 判断 filename1 的修改时间是否比 filename2 的旧。             |
| filename1 -ef filename2 | 判断 filename1 是否和 filename2 的 inode 号一致，可以理解为两个文件是否为同一个文件。这个判断用于判断硬链接是很好的方法 |

| 选 项         | 作 用                          |
| ------------- | ------------------------------ |
| num1 -eq num2 | 判断 num1 是否和 num2 相等。   |
| num1 -ne num2 | 判断 num1 是否和 num2 不相等。 |
| num1 -gt num2 | 判断 num1 是否大于 num2 。     |
| num1 -lt num2 | 判断 num1 是否小于 num2。      |
| num1 -ge num2 | 判断 num1 是否大于等于 num2。  |
| num1 -le num2 | 判断 num1 是否小于等于 num2。  |

| 选 项                    | 作 用                                                        |
| ------------------------ | ------------------------------------------------------------ |
| -z str                   | 判断字符串 str 是否为空。                                    |
| -n str                   | 判断宇符串 str 是否为非空。                                  |
| str1 = str2 str1 == str2 | `=`和`==`是等价的，都用来判断 str1 是否和 str2 相等。        |
| str1 != str2             | 判断 str1 是否和 str2 不相等。                               |
| str1 \> str2             | 判断 str1 是否大于 str2。`\>`是`>`的转义字符，这样写是为了防止`>`被误认为成重定向运算符。 |
| str1 \< str2             | 判断 str1 是否小于 str2。同样，`\<`也是转义字符。            |

| 选 项                      | 作 用                                                        |
| -------------------------- | ------------------------------------------------------------ |
| expression1 -a expression  | 逻辑与，表达式 expression1 和 expression2 都成立，最终的结果才是成立的。 |
| expression1 -o expression2 | 逻辑或，表达式 expression1 和 expression2 有一个成立，最终的结果就成立。 |
| !expression                | 逻辑非，对 expression 进行取反。                             |

所以，当你在 test 命令中使用变量时，我强烈建议将变量用双引号`""`包围起来，这样能避免变量为空值时导致的很多奇葩问题。

#### 3.5.2 [[]]

`[[ ]]`是 Shell 内置关键字，它和 test 命令类似，也用来检测某个条件是否成立。

test 能做到的，[[ ]] 也能做到，而且 [[ ]] 做的更好；test 做不到的，[[ ]] 还能做到。可以认为 [[ ]] 是 test 的升级版，对细节进行了优化，并且扩展了一些功能。

- 不需要把变量名用双引号`""`包围起来，即使变量是空值，也不会出错。
- 不需要、也不能对 >、< 进行转义，转义后会出错。

```shell
[[ expression ]]
```

注意，[[ ]] 剔除了 test 命令的`-o`和`-a`选项，你只能使用 || 和 &&。

| test 或 []                         | [[ ]] |                                    |       |
| ---------------------------------- | ----- | ---------------------------------- | ----- |
| [ -z "$str1" ] \|\| [ -z "$str2" ] | **√** | [[ -z $str1 ]] \|\| [[ -z $str2 ]] | **√** |
| [ -z "$str1" -o -z "$str2" ]       | **√** | [[ -z $str1 -o -z $str2 ]]         | **×** |
| [ -z $str1 \|\| -z $str2 ]         | **×** | [[ -z $str1 \|\| -z $str2 ]]       | **√** |

在 Shell [[ ]] 中，可以使用`=~`来检测字符串是否符合某个正则表达式，它的用法为：

```shell
[[ str =~ regex ]]
```

但是 [[ ]] 对数字的比较仍然不友好，所以我建议，以后大家使用 if 判断条件时，用 (()) 来处理整型数字，用 [[ ]] 来处理字符串或者文件。

### 3.6 分支语句

#### 3.6.1 if else

#### 3.6.2 case in

​		case语法结构如下：

```shell
case expression in
    pattern1)
        statement1
        ;;
    pattern2)
        statement2
        ;;
    pattern3)
        statement3
        ;;
    ……
    *)
        statementn
esac
```

​		case、in 和 esac 都是 Shell 关键字，expression 表示表达式，pattern 表示匹配模式。

- expression 既可以是一个变量、一个数字、一个字符串，还可以是一个数学计算表达式，或者是命令的执行结果，只要能够得到 expression 的值就可以。
- pattern 可以是一个数字、一个字符串，甚至是一个简单的正则表达式。

### 3.7 循环语句

#### 3.7.1 while循环

```shell
while condition
do
    statements
done
```

while 循环的执行流程为：

- 先对 condition 进行判断，如果该条件成立，就进入循环，执行 while 循环体中的语句，也就是 do 和 done 之间的语句。这样就完成了一次循环。
- 每一次执行到 done 的时候都会重新判断 condition 是否成立，如果成立，就进入下一次循环，继续执行 do 和 done 之间的语句，如果不成立，就结束整个 while 循环，执行 done 后面的其它 Shell 代码。
- 如果一开始 condition 就不成立，那么程序就不会进入循环体，do 和 done 之间的语句就没有执行的机会。

#### 3.7.2 until循环

unti 循环和 while 循环恰好相反，当判断条件不成立时才进行循环，一旦判断条件成立，就终止循环。

```shell
until condition
do
    statements
done
```

until 循环的执行流程为：

- 先对 condition 进行判断，如果该条件不成立，就进入循环，执行 until 循环体中的语句（do 和 done 之间的语句），这样就完成了一次循环。
- 每一次执行到 done 的时候都会重新判断 condition 是否成立，如果不成立，就进入下一次循环，继续执行循环体中的语句，如果成立，就结束整个 until 循环，执行 done 后面的其它 Shell 代码。
- 如果一开始 condition 就成立，那么程序就不会进入循环体，do 和 done 之间的语句就没有执行的机会。


注意，在 until 循环体中必须有相应的语句使得 condition 越来越趋近于“成立”，只有这样才能最终退出循环，否则 until 就成了死循环，会一直执行下去，永无休止。

#### 3.7.3 for循环

​		Shell for 循环有两种使用形式，一种是C风格的形式，一种是python风格的形式，这里只介绍python风格的for循环。

##### 3.7.3.1 for的语法结构

​		语法结构如下所示：

```shell
# variable 表示变量，value_list 表示取值列表，in 是 Shell 中的关键字

for variable in value_list
do
    statements
done
```

##### 3.7.3.2 取值列表的规范形式

​		这里的取值列表指的是`value_list`

- 取值列表 value_list 的形式有多种，你可以直接给出具体的值，也可以给出一个范围，还可以使用命令产生的结果，甚至使用通配符;

- 可以在 in 关键字后面直接给出具体的值，多个值之间以空格分隔，比如`1 2 3 4 5`、`"abc" "390" "tom"`等;

- Shell 中有多个特殊的变量，例如 $#、$*、$@、$?、$$ 等，在 value_list 中就可以使用它们；

- 使用反引号````或者`$()`都可以取得命令的执行结果(从编写规范的角度建议使用$());

- 使用通配符；

  ```shell
  # 循环打印以.sh结尾的文件名
  
  for filename in *.sh
  do
      echo $filename
  done
  ```

### 3.10 break和continue

​		在大部分编程语言中，break 和 continue 只能跳出当前层次的循环，内层循环中的 break 和 continue 对外层循环不起作用；但是 Shell 中的 break 和 continue 却能够跳出多层循环，也就是说，内层循环中的 break 和 continue 能够跳出外层循环。

​		break 用来结束所有循环，循环语句不再有执行的机会；continue 用来结束本次循环，直接跳到下一次循环，如果循环条件成立，还会继续循环。

#### 3.10.1 break

```shell
# n 表示跳出循环的层数，如果省略 n，则表示跳出当前的整个循环
# 一般在实际编写脚本的过程中不启用参数n

break n
```

#### 3.10.2 continue

```shell
# 如果省略 n，则表示 continue 只对当前层次的循环语句有效，遇到 continue 会跳过本次循环，忽略本次循环的剩余代码，直接进入下一次循环。

# 如果带上 n，比如 n 的值为 2，那么 continue 对内层和外层循环语句都有效，不但内层会跳过本次循环，外层也会跳过本次循环，其效果相当于内层循环和外层循环同时执行了不带 n 的 continue。
continue n
```
































## 4 函数

### 4.1 函数的基本定义

```shell
# 函数的基本结构如下所示
# 1）关键字function可省略，建议不省略
# 2）函数名后如不传参中括号可省略（省略时function需要保留），建议不省略
# 3）函数体后的返回值为0～255的整数，可省略
[ function ] funname [()]

{

    statement

    [return int]

}

# 为了增强可读性，通常函数写作以下形式

function funname() {
	echo "hello bash!"
	return 0 # 如果函数体中没有 return 语句，那么使用默认的退出状态，也就是最后一条命令的退出状态。
}
```

> **注意事项**：

> - 所有函数在使用前必须定义。这意味着必须将函数放在脚本开始部分，直至shell解释器首次发现它时，才可以使用。调用函数仅使用其函数名即可。


### 4.2 函数的调用和传参

​		函数调用直接通过函数名可以完成调用，不需要使用调用运算符`()`

```shell
function sayHello() {
	echo "hello world!"
}

sayHello
```

​		如果需要给函数传参可以使用如下形式

```shell
# functionName param1 param2 param3

function sayHello() {
	echo "hello ${1} ,your age is ${2}"
}

sayHello achui 18
```

​		函数参数是 Shell 位置参数的一种，在函数内部可以使用$n来接收，例如，$1 表示第一个参数，$2 表示第二个参数，依次类推, 注意，参数n > 10时，需要使用{}划定边界，如${10}

> **注意事项**:

> - `$0` 代表函数名称
> - `$#`代表函数的参数个数
> - `$@`代表一次性获取函数的所有参数 













### shell传参

将文本字符串作为参数传递时,引号并非数据的一部分。它们只是表明数据的起止位置



每个参数都是用空格分隔的,所以shell会将空格当成两个值的分隔符。要在参数值中
包含空格,必须要用引号(单引号或双引号均可)。



如果脚本需要的命令行参数不止9个,你仍然可以处理,但是需要稍微修改一下变量名。在
第9个变量之后,你必须在变量数字周围加上花括号,比如 ${10}



bash shell会将一些称为位置参数(positional parameter)的特殊变量分配给输入到命令行中的
所有参数。



当传给 $0 变量的实际字符串不仅仅是脚本名,而是完整的脚本路径时,
变量 $0 就会使用整个路径。



如果你要编写一个根据脚本名来执行不同功能的脚本,就得做点额外工作。你得把脚本的运
行路径给剥离掉。另外,还要删除与脚本名混杂在一起的命令。
幸好有个方便的小命令可以帮到我们。 basename 命令会返回不包含路径的脚本名。

name=$(basename $0)

## 5 重定向与文件描述符

### 5.1 重定向

#### 5.1.1 重定向的分类

​		Linux Shell 重定向分为两种，一种输入重定向，一种是输出重定向；

- 输入方向就是数据从哪里流向程序。数据默认从键盘流向程序，如果改变了它的方向，数据就从其它地方流入，这就是输入重定向。
- 输出方向就是数据从程序流向哪里。数据默认从程序流向显示器，如果改变了它的方向，数据就流向其它地方，这就是输出重定向。

#### 5.1.2 文件描述符

​		Linux 中一切皆文件，包括标准输入设备（键盘）和标准输出设备（显示器）在内的所有计算机硬件都是文件。为了表示和区分已经打开的文件，Linux 会给每个文件分配一个 ID，这个 ID 就是一个整数，被称为文件描述符（File Descriptor）。

​		Linux 程序在执行任何形式的 I/O 操作时，都是在读取或者写入一个文件描述符。一个文件描述符只是一个和打开的文件相关联的整数，它的背后可能是一个硬盘上的普通文件、FIFO、管道、终端、键盘、显示器，甚至是一个网络连接。

​		stdin、stdout、stderr 默认都是打开的，在重定向的过程中，0、1、2 这三个文件描述符可以直接使用。

| 文件描述符 | 文件名 | 类型             | 硬件   |
| ---------- | ------ | ---------------- | ------ |
| 0          | stdin  | 标准输入文件     | 键盘   |
| 1          | stdout | 标准输出文件     | 显示器 |
| 2          | stderr | 标准错误输出文件 | 显示器 |

#### 5.1.3 输出重定向

​		在输出重定向中，`>`代表的是覆盖，`>>`代表的是追加。

```shell
echo "hello achui" > test # 将标准输出信息输入到test文件中

echo "hello achui" 2> test # 将错误信息输入到test文件中

echo "hello achui" > test 2>&1 # 将错误信息和标准输出信息都输入到test文件中

# /dev/null 文件
# 如果你既不想把命令的输出结果保存到文件，也不想把命令的输出结果显示到屏幕上，干扰命令的执行，那么可以把命令的所有结果重定向到 /dev/null 文件中
# 可以把 /dev/null 当成 Linux 系统的垃圾箱，任何放入垃圾箱的数据都会被丢弃，不能恢复
echo "hello achui" >/dev/null 2>&1
```

> **注意事项：**

> - 输出重定向的完整写法其实是`fd>file`或者`fd>>file`，其中 fd 表示文件描述符，如果不写，默认为 1，也就是标准输出文件;
>
> - 当文件描述符为大于 1 的值时，比如 2，就必须写上;
>
> - 需要重点说明的是，`fd`和`>`之间不能有空格，否则 Shell 会解析失败；

#### 5.1.4 输入重定向

​		输入重定向就是改变输入的方向，不再使用键盘作为命令输入的来源，而是使用文件作为命令的输入。

| 符号                  | 说明                                                         |
| --------------------- | ------------------------------------------------------------ |
| command <file         | 将 file 文件中的内容作为 command 的输入。                    |
| command <<END         | 从标准输入（键盘）中读取数据，直到遇见分界符 END 才停止（分界符可以是任意的字符串，用户自己定义）。 |
| command <file1 >file2 | 将 file1 作为 command 的输入，并将 command 的处理结果输出到 file2。 |

​		`<<`之后的分界符可以自由定义，只要再碰到相同的分界符，两个分界符之间的内容将作为命令的输入（不包括分界符本身），配和无特殊含义的`:`变量，就可以实现shell中的多行注释。

```shell
:<<EOF
	这是一个多行注释
EOF
```

#### 5.1.5 exec

​		exec可以让重定向对当前 Shell 进程中的所有命令有效，它的用法为：

```shell
exec 文件描述符操作
```

#### 5.1.6 Here Document

### 5.2 管道

​		将两个或者多个命令（程序或者进程）连接到一起，把一个命令的输出作为下一个命令的输入，以这种方式连接的两个或者多个命令就形成了**管道（pipe）**，Linux 管道使用竖线`|`连接多个命令，这被称为**管道符**。

​		当在两个命令之间设置管道时，管道符`|`左边命令的输出就变成了右边命令的输入。只要第一个命令向标准输出写入，而第二个命令是从标准输入读取，那么这两个命令就可以形成一个管道。

```shell
ls -alh | wc -l  # 显示有多少行
```

## 6 子shell与子进程

## 7 信号

​		在 Linux 系统（以及其他类 Unix操作系统）中，信号被用于进程间的通信。信号是一个发送到某个进程或同一进程中的特定线程的异步通知，用于通知发生的一个事件。

​		信号同样被用于通信、同步进程和简化进程间通信，在 Linux 中，信号在处理异常和中断方面，扮演了极其重要的角色。

当一个事件发生时，会产生一个信号，然后内核会将事件传递到接收的进程。有时，进程可以发送一个信号到其他进程。除了进程到进程的信号外，还有很多种情况，内核会产生一个信号，比如文件大小达到限额、一个 I/O 设备就绪或用户发送了一个类似于 Ctrl+C 或 Ctrl+Z 的终端中断等。

运行在用户模式下的进程会接收信号。如果接收的进程正运行在内核模式，那么信号的执行只有在该进程返回到用户模式时才会开始。

## 8 Debug

​		shell 提供了用于 debug 脚本的工具。

​		如果想采用 debug 模式运行某脚本，可以在其 shebang 中使用一个特殊的选项：

```
#!/bin/bash options
```

options 是一些可以改变 shell 行为的选项。下表是一些可能对你有用的选项：

| Short | Name        | Description                                                |
| ----- | ----------- | ---------------------------------------------------------- |
| `-f`  | noglob      | 禁止文件名展开（globbing）                                 |
| `-i`  | interactive | 让脚本以 *交互* 模式运行                                   |
| `-n`  | noexec      | 不执行脚本，仅查询语法问题                                 |
| `-t`  | —           | 执行完第一条命令后退出                                     |
| `-v`  | verbose     | 在执行每条命令前，向`stderr`输出该命令                     |
| `-x`  | xtrace      | 在执行每条命令前，向`stderr`输出该命令以及该命令的扩展参数 |